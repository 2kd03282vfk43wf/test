        // ==UserScript==
        // @name         ash9
        // @namespace    http://tampermonkey.net/
        // @version      9.0.0
        // @description  webclip
        // @author
        // @match        *://*/*
        // @grant        GM_getValue
        // @grant        GM_setValue
        // @grant        GM_addStyle
        // ==/UserScript==

        (function() {
            'use strict';

            // エラーハンドリングとログ管理の改善
            const Logger = {
                log(message, level = 'info') {
                    const timestamp = new Date().toLocaleTimeString();
                    const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

                    switch (level) {
                        case 'error':
                            console.error(logEntry);
                            break;
                        case 'warn':
                            console.warn(logEntry);
                            break;
                        default:
                            console.log(logEntry);
                    }

                    // エラーの場合はユーザーに通知
                    if (level === 'error') {
                        this.showUserNotification(message, 'error');
                    }
                },

                showUserNotification(message, type = 'info') {
                    // 既存の通知があれば削除
                    const existingNotification = document.querySelector('.ash8-notification');
                    if (existingNotification) {
                        existingNotification.remove();
                    }

                    const notification = document.createElement('div');
                    notification.className = `ash8-notification ash8-${type}`;
                    notification.textContent = message;
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        padding: 10px 15px;
                        border-radius: 5px;
                        color: white;
                        font-family: sans-serif;
                        font-size: 12px;
                        z-index: 20000;
                        max-width: 300px;
                        word-wrap: break-word;
                        animation: slideIn 0.3s ease-out;
                    `;

                    // タイプ別のスタイル
                    if (type === 'error') {
                        notification.style.backgroundColor = '#e74c3c';
                    } else if (type === 'warn') {
                        notification.style.backgroundColor = '#f39c12';
                    } else {
                        notification.style.backgroundColor = '#27ae60';
                    }

                    document.body.appendChild(notification);

                    // 3秒後に自動削除
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.style.animation = 'slideOut 0.3s ease-in';
                            setTimeout(() => notification.remove(), 300);
                        }
                    }, 3000);
                }
            };

            const logMessage = (message, level = 'info') => Logger.log(message, level);
            const getTimestamp = () => new Date().toISOString();
            const getDateString = () => new Date().toISOString().split('T')[0];

            // エラーハンドリング用のラッパー関数
            const safeExecute = (fn, context = null, fallback = null) => {
                try {
                    return fn.call(context);
                } catch (error) {
                    logMessage(`実行エラー: ${error.message}`, 'error');
                    if (fallback && typeof fallback === 'function') {
                        return fallback.call(context, error);
                    }
                    return null;
                }
            };

            const StateManager = {
                // 永続化される状態
                window: null,
                customTabs: new Set(GM_getValue('customTabs', ['メモ'])),
                tabColors: new Map(Object.entries(GM_getValue('tabColors', {}))),
                tabThumbnails: new Map(Object.entries(GM_getValue('tabThumbnails', {}))),
                tabDomainNames: new Map(Object.entries(GM_getValue('tabDomainNames', {}))),
                elementSelectors: new Map(Object.entries(GM_getValue('elementSelectors', {}))),

                // 一時的な状態
                selectionMode: false,
                videoThumbnailMode: false,
                tagExtractionMode: false,
                compressionRate: 0.7,
                currentCompressedImage: null,
                isDraggingToolbar: false,
                offsetXToolbar: 0,
                offsetYToolbar: 0,
                zIndexCounter: 10000,
                activeMenu: null,
                activePopup: null,
                isHoverEnabled: false,

                // 状態変更メソッド
                setWindow(windowObj) {
                    this.window = windowObj;
                    GM_setValue('savedWindow', windowObj ? windowObj.id : null);
                },

                updateCustomTabs(tabs) {
                    this.customTabs = new Set(tabs);
                    GM_setValue('customTabs', [...this.customTabs]);
                },

                setTabColor(tab, color) {
                    this.tabColors.set(tab, color);
                    GM_setValue('tabColors', Object.fromEntries(this.tabColors));
                },

                setTabThumbnail(tab, thumbnail) {
                    this.tabThumbnails.set(tab, thumbnail);
                    GM_setValue('tabThumbnails', Object.fromEntries(this.tabThumbnails));
                },

                setTabDomainName(tab, showDomainName) {
                    this.tabDomainNames.set(tab, showDomainName);
                    GM_setValue('tabDomainNames', Object.fromEntries(this.tabDomainNames));
                },

                setElementSelectors(domain, selectors) {
                    if (selectors) {
                        this.elementSelectors.set(domain, selectors);
                    } else {
                        this.elementSelectors.delete(domain);
                    }
                    GM_setValue('elementSelectors', Object.fromEntries(this.elementSelectors));
                },

                // 状態のバリデーション
                validateState() {
                                    if (this.compressionRate < 0 || this.compressionRate > 1) {
                    this.compressionRate = 0.7;
                        logMessage('圧縮率をデフォルト値にリセットしました');
                    }

                    if (this.zIndexCounter < 10000) {
                        this.zIndexCounter = 10000;
                    }
                },

                // 状態のリセット
                resetTemporaryState() {
                    this.selectionMode = false;
                    this.videoThumbnailMode = false;
                    this.tagExtractionMode = false;
                    this.isDraggingToolbar = false;
                    this.activeMenu = null;
                    this.activePopup = null;
                    this.isHoverEnabled = false;
                }
            };

            // メモ化機能の実装
            const Memoization = {
                cache: new Map(),

                memoize(fn, keyGenerator = null) {
                    return (...args) => {
                        const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);

                        if (this.cache.has(key)) {
                            return this.cache.get(key);
                        }

                        const result = fn(...args);
                        this.cache.set(key, result);

                        // キャッシュサイズの制限（メモリリーク防止）
                        if (this.cache.size > 100) {
                            const firstKey = this.cache.keys().next().value;
                            this.cache.delete(firstKey);
                        }

                        return result;
                    };
                },

                clearCache() {
                    this.cache.clear();
                }
            };

            const state = new Proxy(StateManager, {
                set(target, prop, value) {
                    const oldValue = target[prop];
                    Reflect.set(target, prop, value);

                    // 状態変更時の処理
                    if (prop === 'currentCompressedImage' && value) {
                        safeExecute(() => {
                            const img = document.getElementById('compressedImage');
                            if (img) img.src = value;
                            if (document.getElementById('autoSaveCheckbox')?.checked) saveImage();
                        });
                    }

                    if (prop === 'window' && value) {
                        safeExecute(() => updateTabs(value));
                    }

                    // 状態のバリデーション
                    if (prop === 'compressionRate' || prop === 'zIndexCounter') {
                        target.validateState();
                    }

                    // 状態変更のログ
                    if (oldValue !== value) {
                        logMessage(`状態変更: ${prop} = ${value}`, 'info');
                    }

                    return true;
                },

                get(target, prop) {
                    // 状態のバリデーション
                    if (prop === 'compressionRate' || prop === 'zIndexCounter') {
                        target.validateState();
                    }
                    return Reflect.get(target, prop);
                }
            });

            const EventManager = {
                handlers: new WeakMap(),
                delegatedHandlers: new Map(),

                add(element, type, handler, options = {}) {
                    if (!element) return;
                    element.addEventListener(type, handler, options);
                    const handlers = this.handlers.get(element) || [];
                    handlers.push({ type, handler, options });
                    this.handlers.set(element, handlers);
                },

                removeAll(element) {
                    const handlers = this.handlers.get(element) || [];
                    handlers.forEach(({ type, handler, options }) => {
                        element.removeEventListener(type, handler, options);
                    });
                    this.handlers.delete(element);
                },

                // イベント委譲の実装
                delegate(parent, selector, type, handler, options = {}) {
                    const delegatedHandler = (event) => {
                        const target = event.target.closest(selector);
                        if (target && parent.contains(target)) {
                            handler.call(target, event, target);
                        }
                    };

                    parent.addEventListener(type, delegatedHandler, options);

                    // 委譲ハンドラーを記録
                    const key = `${parent.id || 'anonymous'}-${type}-${selector}`;
                    this.delegatedHandlers.set(key, { parent, type, handler: delegatedHandler, options });

                    return key;
                },

                // 委譲ハンドラーの削除
                removeDelegated(key) {
                    const handler = this.delegatedHandlers.get(key);
                    if (handler) {
                        handler.parent.removeEventListener(handler.type, handler.handler, handler.options);
                        this.delegatedHandlers.delete(key);
                    }
                },

                // 要素削除時の自動クリーンアップ
                cleanupElement(element) {
                    this.removeAll(element);

                    // 委譲ハンドラーもクリーンアップ
                    for (const [key, handler] of this.delegatedHandlers) {
                        if (handler.parent === element) {
                            this.removeDelegated(key);
                        }
                    }
                }
            };
            const events = EventManager;

            const Toolbar = {
                elements: null,
                init() {
                    try {
                        const toolbar = document.createElement('div');
                        toolbar.id = 'toolbar';
                        const fragment = document.createDocumentFragment();

                        const handle = document.createElement('div'); handle.id = 'toolbarHandle';
                        const selectImgBtn = document.createElement('button'); selectImgBtn.id = 'selectImageButton'; selectImgBtn.textContent = '📸';
                        const selectVidBtn = document.createElement('button'); selectVidBtn.id = 'selectVideoThumbnailButton'; selectVidBtn.textContent = '📹';
                        const extractTagsBtn = document.createElement('button'); extractTagsBtn.id = 'extractTagsButton'; extractTagsBtn.textContent = '📌';
                        const pasteArea = document.createElement('textarea'); pasteArea.id = 'pasteImageArea'; pasteArea.placeholder = 'copy';
                        const compressionDiv = document.createElement('div'); compressionDiv.id = 'compressionButtons';
                        const comp50 = document.createElement('button'); comp50.id = 'compression50'; comp50.textContent = '50';
                        const comp30 = document.createElement('button'); comp30.id = 'compression30'; comp30.textContent = '30';
                        const comp10 = document.createElement('button'); comp10.id = 'compression10'; comp10.textContent = '10';
                        compressionDiv.append(comp50, comp30, comp10);
                        const saveBtn = document.createElement('button'); saveBtn.id = 'saveButton'; saveBtn.textContent = '💾';
                        const autoSave = document.createElement('input'); autoSave.type = 'checkbox'; autoSave.id = 'autoSaveCheckbox'; autoSave.checked = true; autoSave.title = '自動保存';
                        const toggleWinBtn = document.createElement('button'); toggleWinBtn.id = 'toggleWindowButton'; toggleWinBtn.textContent = '🖼️';
                        const compRate = document.createElement('div'); compRate.id = 'compressionRate';
                        const debugOut = document.createElement('div'); debugOut.id = 'debugOutput';
                        const bottomHandle = document.createElement('div'); bottomHandle.id = 'toolbarBottomHandle';

                        fragment.append(handle, selectImgBtn, selectVidBtn, extractTagsBtn, pasteArea, compressionDiv, saveBtn, autoSave, toggleWinBtn, compRate, debugOut, bottomHandle);
                        toolbar.appendChild(fragment);
                        document.body.appendChild(toolbar);

                        this.elements = {
                            toolbar,
                            selectImageButton: toolbar.querySelector('#selectImageButton'),
                            selectVideoThumbnailButton: toolbar.querySelector('#selectVideoThumbnailButton'),
                            extractTagsButton: toolbar.querySelector('#extractTagsButton'),
                            pasteImageArea: toolbar.querySelector('#pasteImageArea'),
                            compressionRateDisplay: toolbar.querySelector('#compressionRate'),
                            debugOutput: toolbar.querySelector('#debugOutput'),
                            saveButton: toolbar.querySelector('#saveButton'),
                            autoSaveCheckbox: toolbar.querySelector('#autoSaveCheckbox'),
                            toggleWindowButton: toolbar.querySelector('#toggleWindowButton'),
                            logButton: toolbar.querySelector('#logButton'),
                            toolbarHandle: toolbar.querySelector('#toolbarHandle'),
                            compression50: toolbar.querySelector('#compression50'),
                            compression30: toolbar.querySelector('#compression30'),
                            compression10: toolbar.querySelector('#compression10'),
                            toolbarBottomHandle: toolbar.querySelector('#toolbarBottomHandle')
                        };

                        logMessage("ツールバー追加成功");
                        this.setupEventListeners();
                        return this.elements;
                    } catch (e) {
                        logMessage(`ツールバー初期化失敗: ${e.message}`);
                        return null;
                    }
                },
                setupEventListeners() {
                    events.add(window, 'load', () => {
                        this.elements.autoSaveCheckbox.checked = true;
                        this.adjustToolbarHeight();
                    });
                    events.add(this.elements.selectImageButton, 'click', () => this.startImageSelectionMode());
                    events.add(this.elements.selectVideoThumbnailButton, 'click', () => this.startVideoThumbnailMode());
                    events.add(this.elements.extractTagsButton, 'click', () => this.startTagExtractionMode());
                    events.add(this.elements.pasteImageArea, 'contextmenu', (e) => this.pasteImageFromClipboard(e));
                    events.add(this.elements.saveButton, 'click', () => saveImage());
                    events.add(this.elements.toggleWindowButton, 'click', () => this.toggleWindow());
                    events.add(this.elements.compression50, 'click', () => this.setCompressionRate(0.5));
                    events.add(this.elements.compression30, 'click', () => this.setCompressionRate(0.3));
                    events.add(this.elements.compression10, 'click', () => this.setCompressionRate(0.1));
                    this.setupDrag();

                    // ウィンドウリサイズ時の動的調整を削除

                    logMessage("ツールバーリスナー設定完了");
                },
                startImageSelectionMode() {
                    if (state.videoThumbnailMode) { state.videoThumbnailMode = false; this.elements.selectVideoThumbnailButton.textContent = "📹"; this.elements.selectVideoThumbnailButton.classList.remove("active"); events.removeAll(document); }
                    state.selectionMode = true; this.elements.selectImageButton.textContent = "ON"; this.elements.selectImageButton.classList.add("active"); events.add(document, 'click', (e) => this.handleImageClick(e), { capture: true });
                    logMessage("画像選択モード開始");
                },
                handleImageClick(event) {
                    if (!state.selectionMode || event.target.tagName.toLowerCase() !== 'img') return;
                    event.preventDefault(); event.stopPropagation(); state.selectionMode = false; this.elements.selectImageButton.textContent = "📸"; this.elements.selectImageButton.classList.remove("active"); events.removeAll(document);
                    const src = new URL(event.target.src, location.href).href; logMessage(`画像選択: ${src}`); this.processImage(src);
                },
                startVideoThumbnailMode() {
                    if (state.selectionMode) { state.selectionMode = false; this.elements.selectImageButton.textContent = "📸"; this.elements.selectImageButton.classList.remove("active"); events.removeAll(document); }
                    state.videoThumbnailMode = true; this.elements.selectVideoThumbnailButton.textContent = "動画をクリック"; this.elements.selectVideoThumbnailButton.classList.add("active"); events.add(document, 'click', (e) => this.handleVideoThumbnailClick(e), { capture: true });

                    // デバッグ情報: ページ内の動画要素を検出してログ出力
                    this.debugVideoElements();
                },

                debugVideoElements() {
                    try {
                        const allVideos = document.querySelectorAll('video');
                        const allIframes = document.querySelectorAll('iframe');
                        const videoContainers = document.querySelectorAll('[class*="video"], [class*="player"], [class*="media"], [class*="jw"], [id*="video"], [id*="player"], [id*="media"], [id*="jw"], [id*="vplayer"]');

                        logMessage(`動画要素検出結果: video要素=${allVideos.length}個, iframe要素=${allIframes.length}個, 動画コンテナ=${videoContainers.length}個`);

                        // video要素の詳細情報
                        allVideos.forEach((video, index) => {
                            const rect = video.getBoundingClientRect();
                            const isVisible = rect.width > 0 && rect.height > 0;
                            const hasSrc = video.src || video.querySelector('source');
                            const className = video.className || '';
                            const id = video.id || '';
                            const hasJwClass = className.includes('jw');
                            const hasPlayerClass = className.includes('player') || className.includes('video') || className.includes('media');
                            const hasVplayerId = id.includes('vplayer');
                            logMessage(`video[${index}]: visible=${isVisible}, hasSrc=${!!hasSrc}, hasJwClass=${hasJwClass}, hasPlayerClass=${hasPlayerClass}, hasVplayerId=${hasVplayerId}, size=${rect.width}x${rect.height}, className="${className}", id="${id}", src=${video.src || 'source要素あり'}`);
                        });

                        // iframe要素の詳細情報
                        allIframes.forEach((iframe, index) => {
                            const rect = iframe.getBoundingClientRect();
                            const isVisible = rect.width > 0 && rect.height > 0;
                            const isVideoRelated = iframe.src && (iframe.src.includes('video') || iframe.src.includes('player') || iframe.src.includes('embed') || iframe.src.includes('jw'));
                            logMessage(`iframe[${index}]: visible=${isVisible}, videoRelated=${isVideoRelated}, size=${rect.width}x${rect.height}, src=${iframe.src}`);
                        });

                        // 動画コンテナの詳細情報
                        videoContainers.forEach((container, index) => {
                            const rect = container.getBoundingClientRect();
                            const isVisible = rect.width > 0 && rect.height > 0;
                            const hasVideo = container.querySelector('video');
                            const className = container.className || '';
                            const id = container.id || '';
                            const hasJwClass = className.includes('jw') || id.includes('jw');
                            const hasVplayerId = id.includes('vplayer');
                            logMessage(`container[${index}]: visible=${isVisible}, hasVideo=${!!hasVideo}, hasJwClass=${hasJwClass}, hasVplayerId=${hasVplayerId}, size=${rect.width}x${rect.height}, className="${className}", id="${id}"`);
                        });

                        // 特定の動画プレーヤー要素を検索
                        const jwElements = document.querySelectorAll('[class*="jw"]');
                        const playerElements = document.querySelectorAll('[class*="player"]');
                        const videoElements = document.querySelectorAll('[class*="video"]');
                        const vplayerElements = document.querySelectorAll('[id*="vplayer"], [class*="vplayer"]');

                        logMessage(`特定要素検出: jw関連=${jwElements.length}個, player関連=${playerElements.length}個, video関連=${videoElements.length}個, vplayer関連=${vplayerElements.length}個`);

                        // JW Player関連要素の詳細
                        jwElements.forEach((element, index) => {
                            const rect = element.getBoundingClientRect();
                            const isVisible = rect.width > 0 && rect.height > 0;
                            const hasVideo = element.querySelector('video');
                            logMessage(`jw[${index}]: visible=${isVisible}, hasVideo=${!!hasVideo}, tagName=${element.tagName}, className="${element.className}", id="${element.id}"`);
                        });

                        // VPlayer関連要素の詳細
                        vplayerElements.forEach((element, index) => {
                            const rect = element.getBoundingClientRect();
                            const isVisible = rect.width > 0 && rect.height > 0;
                            const hasVideo = element.querySelector('video');
                            const isVideoElement = element.tagName.toLowerCase() === 'video';
                            logMessage(`vplayer[${index}]: visible=${isVisible}, hasVideo=${!!hasVideo}, isVideoElement=${isVideoElement}, tagName=${element.tagName}, className="${element.className}", id="${element.id}"`);
                        });

                        // すべての要素をIDで検索（デバッグ用）
                        const allElementsWithId = document.querySelectorAll('[id]');
                        const vplayerRelatedElements = Array.from(allElementsWithId).filter(el =>
                            el.id.toLowerCase().includes('vplayer') ||
                            el.id.toLowerCase().includes('player') ||
                            el.id.toLowerCase().includes('video')
                        );

                        logMessage(`ID検索結果: vplayer関連要素=${vplayerRelatedElements.length}個`);
                        vplayerRelatedElements.forEach((element, index) => {
                            const rect = element.getBoundingClientRect();
                            const isVisible = rect.width > 0 && rect.height > 0;
                            const hasVideo = element.querySelector('video');
                            const isVideoElement = element.tagName.toLowerCase() === 'video';
                            logMessage(`id-search[${index}]: visible=${isVisible}, hasVideo=${!!hasVideo}, isVideoElement=${isVideoElement}, tagName=${element.tagName}, id="${element.id}", className="${element.className}"`);
                        });

                    } catch (error) {
                        logMessage(`動画要素デバッグエラー: ${error.message}`);
                    }
                },
                handleVideoThumbnailClick(event) {
                    if (!state.videoThumbnailMode) return;

                    // 動画要素を検索（クリックされた要素とその親要素から）
                    let videoElement = null;
                    let target = event.target;

                    // クリックされた要素が動画要素かチェック
                    if (target.tagName.toLowerCase() === 'video') {
                        videoElement = target;
                    } else if (target.tagName.toLowerCase() === 'iframe') {
                        videoElement = target;
                    } else {
                        // より包括的な動画要素セレクター
                        const videoSelectors = [
                            // 基本的なvideo要素
                            'video',
                            'video[src]',
                            'video source',

                            // 一般的な動画プレーヤークラス
                            '.jw-video',
                            '.jwplayer video',
                            '.jwplayer',
                            '.video-js video',
                            '.video-js',
                            '.plyr video',
                            '.plyr',
                            '.mejs video',
                            '.mejs',
                            '.flowplayer video',
                            '.flowplayer',
                            '.jw-video-container video',
                            '.jw-video-container',
                            '.jw-video-wrapper video',
                            '.jw-video-wrapper',

                                                    // 汎用的な動画プレーヤークラス
                        '[class*="jw-"] video',
                        '[class*="jw-"]',
                        '[class*="player-"] video',
                        '[class*="player-"]',
                        '[class*="video-"] video',
                        '[class*="video-"]',
                        '[class*="media-"] video',
                        '[class*="media-"]',
                        '[class*="stream-"] video',
                        '[class*="stream-"]',
                        '[class*="live-"] video',
                        '[class*="live-"]',
                        '[class*="vplayer"] video',
                        '[class*="vplayer"]',
                        '[id*="vplayer"] video',
                        '[id*="vplayer"]',

                            // iframe関連
                            'iframe[src*="video"]',
                            'iframe[src*="player"]',
                            'iframe[src*="embed"]',
                            'iframe[src*="youtube"]',
                            'iframe[src*="vimeo"]',
                            'iframe[src*="dailymotion"]',
                            'iframe[src*="twitch"]',
                            'iframe[src*="bilibili"]',
                            'iframe[src*="nicovideo"]',
                            'iframe[src*="stream"]',
                            'iframe[src*="live"]',
                            'iframe[src*="jw"]',
                            'iframe[src*="jwplayer"]',

                            // 動画プレーヤー関連
                            '.video-player video',
                            '.player video',
                            '.media-player video',
                            '.video-container video',
                            '.player-container video',
                            '.video-wrapper video',
                            '.player-wrapper video',
                            '.stream-player video',
                            '.live-player video',

                                                    // クラス名パターン（より包括的）
                        '[class*="video"] video',
                        '[class*="player"] video',
                        '[class*="media"] video',
                        '[class*="stream"] video',
                        '[class*="live"] video',
                        '[class*="jw"] video',
                        '[class*="jw"]',
                        '[class*="vplayer"] video',
                        '[class*="vplayer"]',

                                                    // データ属性
                        '[data-video]',
                        '[data-player]',
                        '[data-stream]',
                        '[data-media]',
                        '[data-jw]',
                        '[data-jwplayer]',
                        '[data-vplayer]',

                            // その他の動画要素
                            'object[type*="video"]',
                            'embed[type*="video"]',
                            'object[data*="video"]',
                            'embed[src*="video"]',

                                                    // より広範囲な検索
                        '[id*="video"] video',
                        '[id*="player"] video',
                        '[id*="media"] video',
                        '[id*="stream"] video',
                        '[id*="live"] video',
                        '[id*="jw"] video',
                        '[id*="jw"]',
                        '[id*="vplayer"] video',
                        '[id*="vplayer"]',

                                                    // 動画プレーヤーのコンテナ
                        '[class*="video-player"]',
                        '[class*="player-container"]',
                        '[class*="media-player"]',
                        '[class*="stream-player"]',
                        '[class*="live-player"]',
                        '[class*="jw-player"]',
                        '[class*="jw-container"]',
                        '[class*="vplayer"]',
                        '[id*="vplayer"]',

                                                    // より具体的なセレクター
                        'div[class*="video"] video',
                        'div[class*="player"] video',
                        'div[class*="media"] video',
                        'div[class*="jw"] video',
                        'div[class*="jw"]',
                        'div[class*="vplayer"] video',
                        'div[class*="vplayer"]',
                        'div[id*="vplayer"] video',
                        'div[id*="vplayer"]',
                        'section[class*="video"] video',
                        'section[class*="player"] video',
                        'section[class*="jw"] video',
                        'section[class*="jw"]',
                        'section[class*="vplayer"] video',
                        'section[class*="vplayer"]',
                        'article[class*="video"] video',
                        'article[class*="player"] video',
                        'article[class*="jw"] video',
                        'article[class*="jw"]',
                        'article[class*="vplayer"] video',
                        'article[class*="vplayer"]',

                                                    // さらに汎用的な検索
                        'video[class*="jw"]',
                        'video[class*="player"]',
                        'video[class*="video"]',
                        'video[class*="media"]',
                        'video[class*="stream"]',
                        'video[class*="live"]',
                        'video[class*="vplayer"]',
                        'video[id*="vplayer"]',

                            // 属性ベースの検索
                            'video[src*="blob:"]',
                            'video[src*="data:"]',
                            'video[src*="http"]',
                            'video[src*="https"]',
                            'video[webkit-playsinline]',
                            'video[playsinline]',
                            'video[disableremoteplayback]'
                        ];

                        // クリックされた要素の親要素から動画要素を検索
                        let parent = target;
                        let searchDepth = 0;
                        const maxSearchDepth = 15; // 検索深度を増加

                        while (parent && parent !== document.body && searchDepth < maxSearchDepth) {
                            // まず、親要素自体が動画要素かチェック
                            if (parent.tagName.toLowerCase() === 'video' || parent.tagName.toLowerCase() === 'iframe') {
                                videoElement = parent;
                                break;
                            }

                            // 親要素内の動画要素を検索
                            const foundVideo = parent.querySelector(videoSelectors.join(','));
                            if (foundVideo) {
                                videoElement = foundVideo;
                                break;
                            }

                                                    // 親要素自体が動画プレーヤーコンテナかチェック
                        const parentClasses = parent.className || '';
                        const parentId = parent.id || '';
                        if (parentClasses.includes('video') || parentClasses.includes('player') ||
                            parentClasses.includes('media') || parentClasses.includes('stream') ||
                            parentClasses.includes('jw') || parentClasses.includes('jw-') ||
                            parentClasses.includes('vplayer') ||
                            parentId.includes('video') || parentId.includes('player') ||
                            parentId.includes('media') || parentId.includes('stream') ||
                            parentId.includes('jw') || parentId.includes('vplayer')) {

                            // このコンテナ内のvideo要素を検索
                            const videoInContainer = parent.querySelector('video');
                            if (videoInContainer) {
                                videoElement = videoInContainer;
                                break;
                            }
                        }

                            parent = parent.parentElement;
                            searchDepth++;
                        }

                        // ページ全体から動画要素を検索（フォールバック）
                        if (!videoElement) {
                            // まずvideo要素を検索
                            const allVideos = document.querySelectorAll('video');
                            if (allVideos.length > 0) {
                                // クリック位置に最も近い動画要素を選択
                                let closestVideo = null;
                                let minDistance = Infinity;

                                allVideos.forEach(video => {
                                    const rect = video.getBoundingClientRect();
                                    if (rect.width > 0 && rect.height > 0) { // 表示されている要素のみ
                                        const centerX = rect.left + rect.width / 2;
                                        const centerY = rect.top + rect.height / 2;
                                        const distance = Math.sqrt(
                                            Math.pow(event.clientX - centerX, 2) +
                                            Math.pow(event.clientY - centerY, 2)
                                        );

                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            closestVideo = video;
                                        }
                                    }
                                });

                                videoElement = closestVideo;
                            } else {
                                // video要素がない場合はiframeを検索
                                const allIframes = document.querySelectorAll('iframe[src*="video"], iframe[src*="player"], iframe[src*="embed"], iframe[src*="stream"], iframe[src*="live"]');
                                if (allIframes.length > 0) {
                                    let closestIframe = null;
                                    let minDistance = Infinity;

                                    allIframes.forEach(iframe => {
                                        const rect = iframe.getBoundingClientRect();
                                        if (rect.width > 0 && rect.height > 0) { // 表示されている要素のみ
                                            const centerX = rect.left + rect.width / 2;
                                            const centerY = rect.top + rect.height / 2;
                                            const distance = Math.sqrt(
                                                Math.pow(event.clientX - centerX, 2) +
                                                Math.pow(event.clientY - centerY, 2)
                                            );

                                            if (distance < minDistance) {
                                                minDistance = distance;
                                                closestIframe = iframe;
                                            }
                                        }
                                    });

                                    videoElement = closestIframe;
                                }
                            }
                        }

                                            // さらに包括的な検索（動的に読み込まれる動画要素のため）
                    if (!videoElement) {
                        // 直接的なID検索（#vplayerなど）
                        const directIdSearch = document.getElementById('vplayer');
                        if (directIdSearch) {
                            if (directIdSearch.tagName.toLowerCase() === 'video') {
                                videoElement = directIdSearch;
                            } else {
                                const videoInDirectId = directIdSearch.querySelector('video');
                                if (videoInDirectId) {
                                    videoElement = videoInDirectId;
                                }
                            }
                        }

                        // より広範囲なセレクターで検索
                        const comprehensiveSelectors = [
                            'video',
                            'video[class*="jw"]',
                            'video[class*="player"]',
                            'video[class*="video"]',
                            'video[class*="media"]',
                            'video[class*="stream"]',
                            'video[class*="live"]',
                            'video[class*="vplayer"]',
                            'video[id*="vplayer"]',
                            'video[src*="blob:"]',
                            'video[src*="data:"]',
                            'video[src*="http"]',
                            'video[src*="https"]',
                            'video[webkit-playsinline]',
                            'video[playsinline]',
                            'video[disableremoteplayback]',
                            'iframe[src*="video"]',
                            'iframe[src*="player"]',
                            'iframe[src*="embed"]',
                            'iframe[src*="stream"]',
                            'iframe[src*="live"]',
                            'iframe[src*="youtube"]',
                            'iframe[src*="vimeo"]',
                            'iframe[src*="twitch"]',
                            'iframe[src*="bilibili"]',
                            'iframe[src*="nicovideo"]',
                            'iframe[src*="dailymotion"]',
                            'iframe[src*="jw"]',
                            'iframe[src*="jwplayer"]',
                            'iframe[src*="vplayer"]',
                            '[class*="jw-"]',
                            '[class*="jw-"] video',
                            '[class*="vplayer"]',
                            '[class*="vplayer"] video',
                            '[class*="video-player"]',
                            '[class*="player-container"]',
                            '[class*="media-player"]',
                            '[class*="stream-player"]',
                            '[class*="live-player"]',
                            '[class*="jw-player"]',
                            '[class*="jw-container"]',
                            '[id*="video-player"]',
                            '[id*="player-container"]',
                            '[id*="media-player"]',
                            '[id*="jw"]',
                            '[id*="jw"] video',
                            '[id*="vplayer"]',
                            '[id*="vplayer"] video',
                            '[data-video]',
                            '[data-player]',
                            '[data-stream]',
                            '[data-media]',
                            '[data-jw]',
                            '[data-jwplayer]',
                            '[data-vplayer]'
                        ];

                            const allPossibleElements = document.querySelectorAll(comprehensiveSelectors.join(','));
                            if (allPossibleElements.length > 0) {
                                let closestElement = null;
                                let minDistance = Infinity;

                                allPossibleElements.forEach(element => {
                                    const rect = element.getBoundingClientRect();
                                    if (rect.width > 0 && rect.height > 0) {
                                        const centerX = rect.left + rect.width / 2;
                                        const centerY = rect.top + rect.height / 2;
                                        const distance = Math.sqrt(
                                            Math.pow(event.clientX - centerX, 2) +
                                            Math.pow(event.clientY - centerY, 2)
                                        );

                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            closestElement = element;
                                        }
                                    }
                                });

                                if (closestElement) {
                                    // 要素がvideo要素でない場合は、その中にvideo要素があるかチェック
                                    if (closestElement.tagName.toLowerCase() === 'video') {
                                        videoElement = closestElement;
                                    } else {
                                        const videoInElement = closestElement.querySelector('video');
                                        if (videoInElement) {
                                            videoElement = videoInElement;
                                        } else if (closestElement.tagName.toLowerCase() === 'iframe') {
                                            videoElement = closestElement;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (!videoElement) {
                        logMessage('動画要素が見つかりませんでした');
                        return;
                    }

                    event.preventDefault();
                    event.stopPropagation();
                    state.videoThumbnailMode = false;
                    this.elements.selectVideoThumbnailButton.textContent = "📹";
                    this.elements.selectVideoThumbnailButton.classList.remove("active");
                    events.removeAll(document);

                    // 動画の種類に応じてサムネイル取得
                    if (videoElement.tagName.toLowerCase() === 'video') {
                        this.captureVideoThumbnail(videoElement);
                    } else if (videoElement.tagName.toLowerCase() === 'iframe') {
                        this.captureIframeThumbnail(videoElement);
                    } else {
                        logMessage('サポートされていない動画要素です');
                    }
                },

                captureVideoThumbnail(videoElement) {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = videoElement.videoWidth || 640;
                        canvas.height = videoElement.videoHeight || 360;
                        const ctx = canvas.getContext('2d');

                        // 動画が読み込まれているかチェック
                        if (videoElement.readyState >= 2) {
                            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                            const thumbnailDataURL = canvas.toDataURL('image/jpeg', state.compressionRate);
                            logMessage(`サムネイルキャプチャ完了: ${canvas.width}x${canvas.height}`);
                            this.processImage(thumbnailDataURL, true);
                        } else {
                            // 動画が読み込まれていない場合は待機
                            const checkReadyState = () => {
                                if (videoElement.readyState >= 2) {
                                    ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                                    const thumbnailDataURL = canvas.toDataURL('image/jpeg', state.compressionRate);
                                    logMessage(`サムネイルキャプチャ完了: ${canvas.width}x${canvas.height}`);
                                    this.processImage(thumbnailDataURL, true);
                                } else {
                                    setTimeout(checkReadyState, 100);
                                }
                            };
                            checkReadyState();
                        }
                    } catch (error) {
                        logMessage(`動画サムネイル取得エラー: ${error.message}`);
                    }
                },

                captureIframeThumbnail(iframeElement) {
                    try {
                        // iframeのsrcから動画IDを抽出
                        const src = iframeElement.src;
                        let videoId = null;
                        let thumbnailUrl = null;

                        // YouTube
                        if (src.includes('youtube.com') || src.includes('youtu.be')) {
                            const match = src.match(/(?:youtube\.com\/embed\/|youtu\.be\/|youtube\.com\/watch\?v=)([^&\?\/]+)/);
                            if (match) {
                                videoId = match[1];
                                thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
                            }
                        }

                        // Vimeo
                        else if (src.includes('vimeo.com')) {
                            const match = src.match(/vimeo\.com\/(\d+)/);
                            if (match) {
                                videoId = match[1];
                                // VimeoのサムネイルはAPIが必要なので、プレースホルダーを使用
                                logMessage('Vimeo動画のサムネイル取得にはAPIが必要です');
                                thumbnailUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#1ab7ea"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">Vimeo動画</text></svg>';
                            }
                        }

                        // Dailymotion
                        else if (src.includes('dailymotion.com')) {
                            const match = src.match(/dailymotion\.com\/embed\/video\/([^&\?\/]+)/);
                            if (match) {
                                videoId = match[1];
                                // DailymotionのサムネイルはAPIが必要なので、プレースホルダーを使用
                                logMessage('Dailymotion動画のサムネイル取得にはAPIが必要です');
                                thumbnailUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#0066dc"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">Dailymotion動画</text></svg>';
                            }
                        }

                        // Twitch
                        else if (src.includes('twitch.tv')) {
                            const match = src.match(/twitch\.tv\/videos\/(\d+)/);
                            if (match) {
                                videoId = match[1];
                                // TwitchのサムネイルはAPIが必要なので、プレースホルダーを使用
                                logMessage('Twitch動画のサムネイル取得にはAPIが必要です');
                                thumbnailUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#6441a5"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">Twitch動画</text></svg>';
                            }
                        }

                        // Bilibili
                        else if (src.includes('bilibili.com')) {
                            const match = src.match(/bilibili\.com\/video\/([^&\?\/]+)/);
                            if (match) {
                                videoId = match[1];
                                // BilibiliのサムネイルはAPIが必要なので、プレースホルダーを使用
                                logMessage('Bilibili動画のサムネイル取得にはAPIが必要です');
                                thumbnailUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#00a1d6"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">Bilibili動画</text></svg>';
                            }
                        }

                        // NicoNico
                        else if (src.includes('nicovideo.jp')) {
                            const match = src.match(/nicovideo\.jp\/watch\/([^\/\?]+)/);
                            if (match) {
                                videoId = match[1];
                                // NicoNicoのサムネイルはAPIが必要なので、プレースホルダーを使用
                                logMessage('NicoNico動画のサムネイル取得にはAPIが必要です');
                                thumbnailUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#ff6b6b"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">NicoNico動画</text></svg>';
                            }
                        }

                        // その他の動画サイト
                        else {
                            logMessage('サポートされていない動画サイトです');
                            thumbnailUrl = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#104437"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">動画サムネイル</text></svg>';
                        }

                        if (thumbnailUrl) {
                            this.processImage(thumbnailUrl, true);
                        } else {
                            logMessage('動画IDの抽出に失敗しました');
                            this.processImage('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#104437"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">動画サムネイル</text></svg>', true);
                        }

                    } catch (error) {
                        logMessage(`iframeサムネイル取得エラー: ${error.message}`);
                        this.processImage('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 360"><rect width="640" height="360" fill="#104437"/><text x="320" y="180" text-anchor="middle" fill="white" font-size="24">エラー</text></svg>', true);
                    }
                },
                startTagExtractionMode() {
                    state.tagExtractionMode = true; this.elements.extractTagsButton.textContent = "タグ抽出中"; this.elements.extractTagsButton.classList.add("active");
                    const { tags, extractedDate } = extractTagsAndDate();
                    if (tags.length || extractedDate) {
                        const domain = window.location.hostname; const savedData = { image: state.currentCompressedImage || '', url: window.location.href, title: document.title, favicon: getFaviconForNewTab(domain, window.location.href), timestamp: getTimestamp(), tab: domain, tags, extractedDate };
                        const allItems = GM_getValue('savedItems', []); allItems.push(savedData); GM_setValue('savedItems', allItems);
                        if (state.window) { state.window.activeTab = domain; updateTabs(state.window); }
                        logMessage('タグと日付保存成功');
                    }
                    state.tagExtractionMode = false; this.elements.extractTagsButton.textContent = "📌"; this.elements.extractTagsButton.classList.remove("active");
                },
                setCompressionRate(rate) { state.compressionRate = rate; document.querySelectorAll('#compressionButtons button').forEach(b => b.classList.remove('selected')); document.getElementById(`compression${rate * 100}`).classList.add('selected'); this.startImageSelectionMode(); },
                pasteImageFromClipboard(event) {
                    event.preventDefault(); logMessage('クリップボードから画像貼り付け開始');
                    navigator.clipboard.read().then(data => {
                        if (!data.some(item => item.types.some(type => type.startsWith('image/')))) { logMessage('クリップボードに画像なし'); return; }
                        for (const item of data) {
                            for (const type of item.types) {
                                if (type.startsWith('image/')) {
                                    item.getType(type).then(blob => {
                                        const reader = new FileReader(); reader.onload = (e) => this.processImage(e.target.result); reader.readAsDataURL(blob);
                                    }).catch(err => logMessage(`クリップボード画像取得失敗: ${err.message}`));
                                    break;
                                }
                            }
                        }
                    }).catch(err => logMessage(`クリップボード読み込み失敗: ${err.message}`));
                },
                processImage(src, isVideoThumbnail = false) {
                    const img = new Image(); img.crossOrigin = "Anonymous"; img.src = src;
                    img.onload = () => {
                        try {
                                                // 最大サイズ制限（150x150px）
                        const maxWidth = 150;
                        const maxHeight = 150;

                            let targetWidth, targetHeight;
                            let quality;

                            if (isVideoThumbnail) {
                                // 動画サムネイルの場合：圧縮ボタンの設定を反映
                                targetWidth = Math.min(img.width, maxWidth);
                                targetHeight = Math.min(img.height, maxHeight);
                                quality = state.compressionRate; // 圧縮ボタンの設定を使用
                            } else {
                                // 通常の画像の場合：動画サムネイルと同様の品質設定
                                targetWidth = Math.min(img.width, maxWidth);
                                targetHeight = Math.min(img.height, maxHeight);
                                quality = state.compressionRate; // 圧縮ボタンの設定を使用
                            }

                            // 最大サイズを超える場合は縮小
                            if (targetWidth > maxWidth || targetHeight > maxHeight) {
                                const ratio = Math.min(maxWidth / targetWidth, maxHeight / targetHeight);
                                targetWidth = Math.floor(targetWidth * ratio);
                                targetHeight = Math.floor(targetHeight * ratio);
                            }

                            const canvas = document.createElement('canvas');
                            canvas.width = targetWidth;
                            canvas.height = targetHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                            const compressedDataURL = canvas.toDataURL('image/jpeg', quality);
                            state.currentCompressedImage = compressedDataURL;
                            const originalDataURL = canvas.toDataURL('image/jpeg', 1.0);
                            const rate = ((1 - compressedDataURL.length / originalDataURL.length) * 100).toFixed(2);

                            this.elements.compressionRateDisplay.textContent = `圧縮率: ${rate}% (${targetWidth}x${targetHeight})`;
                            logMessage(`画像圧縮成功: ${rate}% (${targetWidth}x${targetHeight})`);
                        } catch (e) { logMessage(`画像圧縮失敗: ${e.message}`); this.elements.compressionRateDisplay.textContent = "圧縮失敗"; }
                    };
                    img.onerror = () => { logMessage(`画像読み込み失敗: ${src} (CORSの可能性)`); this.elements.compressionRateDisplay.textContent = "画像読み込み失敗"; };
                },
                exportItems() {
                    try {
                        const allItems = GM_getValue('savedItems', []);
                        const customTabs = [...state.customTabs];
                        const tabColors = Object.fromEntries(state.tabColors);
                        const tabThumbnails = Object.fromEntries(state.tabThumbnails);

                        // タグ設定を収集
                        const tagSettings = {};
                        const allTabs = [...state.customTabs, ...Array.from(new Set(allItems.map(item => item.tab)))];

                        allTabs.forEach(tab => {
                            tagSettings[tab] = {
                                tagGroups: GM_getValue(`tagGroups-${tab}`, {}),
                                excludeTags: GM_getValue(`excludeTags-${tab}`, [])
                            };
                        });

                        // アイテム表示設定を収集
                        const displaySettings = {};
                        allTabs.forEach(tab => {
                            displaySettings[tab] = {
                                sortOrder: GM_getValue(`sortOrder-${tab}`, 'newest'),
                                layout: GM_getValue(`layout-${tab}`, 'tile'),
                                itemSize: GM_getValue(`itemSize-${tab}`, 'standard'),
                                displayMode: GM_getValue(`displayMode-${tab}`, 'full'),
                                multiSelectMode: GM_getValue(`multiSelectMode-${tab}`, false)
                            };
                        });

                        // Tampermonkey設定を収集
                        const tampermonkeySettings = this.collectTampermonkeySettings();

                        const exportData = {
                            items: allItems,
                            customTabs,
                            tabColors,
                            tabThumbnails,
                            tagSettings,
                            displaySettings,
                            tampermonkeySettings
                        };
                        const jsonStr = JSON.stringify(exportData, null, 2);
                        const blob = new Blob([jsonStr], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `saved_items_${getDateString()}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        logMessage('アイテム、タグ設定、表示設定、Tampermonkey設定のエクスポート成功');
                        alert('エクスポートが完了しました。');
                    } catch (e) {
                        logMessage(`エクスポート失敗: ${e.message}`);
                        alert('エクスポートに失敗しました。');
                    }
                },
                collectTampermonkeySettings() {
                    try {
                        const settings = {
                            userExcludes: GM_getValue('userExcludes', []),
                            userIncludes: GM_getValue('userIncludes', []),
                            otherSettings: {}
                        };

                        // その他のTampermonkey設定を収集
                        const allKeys = Object.keys(localStorage).filter(key => key.startsWith('tm_'));
                        allKeys.forEach(key => {
                            const value = GM_getValue(key, null);
                            if (value !== null) {
                                settings.otherSettings[key] = value;
                            }
                        });

                        logMessage(`Tampermonkey設定を収集: 除外${settings.userExcludes.length}件、含める${settings.userIncludes.length}件、その他${Object.keys(settings.otherSettings).length}件`);
                        return settings;
                    } catch (error) {
                        logMessage(`Tampermonkey設定収集エラー: ${error.message}`, 'error');
                        return { userExcludes: [], userIncludes: [], otherSettings: {} };
                    }
                },
                importItems() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            try {
                                const data = JSON.parse(ev.target.result);
                                if (!data.items || !Array.isArray(data.items)) throw new Error('無効なJSON形式');
                                const confirmMerge = confirm('既存のデータを保持してマージしますか？（いいえを選択すると上書きされます）');
                                let allItems = confirmMerge ? GM_getValue('savedItems', []) : [];
                                allItems = [...allItems, ...data.items];
                                GM_setValue('savedItems', allItems);
                                if (data.customTabs && Array.isArray(data.customTabs)) {
                                    state.updateCustomTabs([...new Set([...state.customTabs, ...data.customTabs])]);
                                }
                                if (data.tabColors && typeof data.tabColors === 'object') {
                                    Object.entries(data.tabColors).forEach(([tab, color]) => state.setTabColor(tab, color));
                                }
                                if (data.tabThumbnails && typeof data.tabThumbnails === 'object') {
                                    Object.entries(data.tabThumbnails).forEach(([tab, thumbnail]) => state.setTabThumbnail(tab, thumbnail));
                                }

                                // タグ設定をインポート
                                if (data.tagSettings && typeof data.tagSettings === 'object') {
                                    Object.entries(data.tagSettings).forEach(([tab, settings]) => {
                                        if (settings.tagGroups && typeof settings.tagGroups === 'object') {
                                            GM_setValue(`tagGroups-${tab}`, settings.tagGroups);
                                        }
                                        if (settings.excludeTags && Array.isArray(settings.excludeTags)) {
                                            GM_setValue(`excludeTags-${tab}`, settings.excludeTags);
                                        }
                                    });
                                }

                                // アイテム表示設定をインポート
                                if (data.displaySettings && typeof data.displaySettings === 'object') {
                                    Object.entries(data.displaySettings).forEach(([tab, settings]) => {
                                        if (settings.sortOrder) GM_setValue(`sortOrder-${tab}`, settings.sortOrder);
                                        if (settings.layout) GM_setValue(`layout-${tab}`, settings.layout);
                                        if (settings.itemSize) GM_setValue(`itemSize-${tab}`, settings.itemSize);
                                        if (settings.displayMode) GM_setValue(`displayMode-${tab}`, settings.displayMode);
                                        if (settings.multiSelectMode !== undefined) GM_setValue(`multiSelectMode-${tab}`, settings.multiSelectMode);
                                    });
                                }

                                // Tampermonkey設定をインポート
                                if (data.tampermonkeySettings && typeof data.tampermonkeySettings === 'object') {
                                    this.importTampermonkeySettings(data.tampermonkeySettings);
                                }

                                if (state.window) {
                                    updateTabs(state.window);
                                    displaySavedItems(state.window);
                                }
                                logMessage('アイテム、タグ設定、表示設定、Tampermonkey設定のインポート成功');
                                alert('インポートが完了しました。');
                            } catch (err) {
                                logMessage(`インポート失敗: ${err.message}`);
                                alert('インポートの処理に失敗しました。ファイルを確認してください。');
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                },
                importTampermonkeySettings(settings) {
                    try {
                        // ユーザーによる除外設定をインポート
                        if (settings.userExcludes && Array.isArray(settings.userExcludes)) {
                            // 現在の除外設定を取得
                            const currentExcludes = GM_getValue('userExcludes', []);
                            const mergedExcludes = [...new Set([...currentExcludes, ...settings.userExcludes])];
                            GM_setValue('userExcludes', mergedExcludes);
                            logMessage(`ユーザー除外設定をインポート: ${settings.userExcludes.length}件`);
                        }

                        // ユーザーによる含める設定をインポート
                        if (settings.userIncludes && Array.isArray(settings.userIncludes)) {
                            const currentIncludes = GM_getValue('userIncludes', []);
                            const mergedIncludes = [...new Set([...currentIncludes, ...settings.userIncludes])];
                            GM_setValue('userIncludes', mergedIncludes);
                            logMessage(`ユーザー含める設定をインポート: ${settings.userIncludes.length}件`);
                        }

                        // その他のTampermonkey設定
                        if (settings.otherSettings && typeof settings.otherSettings === 'object') {
                            Object.entries(settings.otherSettings).forEach(([key, value]) => {
                                GM_setValue(`tm_${key}`, value);
                            });
                            logMessage(`その他のTampermonkey設定をインポート: ${Object.keys(settings.otherSettings).length}件`);
                        }

                        logMessage('Tampermonkey設定のインポート完了');
                    } catch (error) {
                        logMessage(`Tampermonkey設定インポートエラー: ${error.message}`, 'error');
                    }
                },
                setupDrag() {
                    const handleMove = (e) => {
                        if (state.isDraggingToolbar) {
                            let leftPx = e.clientX - state.offsetXToolbar; let topPx = e.clientY - state.offsetYToolbar; leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - this.elements.toolbar.offsetWidth)); topPx = Math.max(0, Math.min(topPx, window.innerHeight - this.elements.toolbar.offsetHeight));
                            requestAnimationFrame(() => { this.elements.toolbar.style.left = `${leftPx}px`; this.elements.toolbar.style.top = `${topPx}px`; });
                        }
                    };
                    const handleUp = () => { if (state.isDraggingToolbar) { GM_setValue('toolbarPosition', { left: this.elements.toolbar.style.left, top: this.elements.toolbar.style.top }); state.isDraggingToolbar = false; document.removeEventListener('mousemove', handleMove); document.removeEventListener('mouseup', handleUp); } };
                    events.add(this.elements.toolbarHandle, 'mousedown', (e) => { state.isDraggingToolbar = true; state.offsetXToolbar = e.clientX - this.elements.toolbar.offsetLeft; state.offsetYToolbar = e.clientY - this.elements.toolbar.offsetTop; e.preventDefault(); document.addEventListener('mousemove', handleMove); document.addEventListener('mouseup', handleUp); });
                    events.add(this.elements.toolbarBottomHandle, 'mousedown', (e) => { state.isDraggingToolbar = true; state.offsetXToolbar = e.clientX - this.elements.toolbar.offsetLeft; state.offsetYToolbar = e.clientY - this.elements.toolbar.offsetTop; e.preventDefault(); document.addEventListener('mousemove', handleMove); document.addEventListener('mouseup', handleUp); });
                },

                adjustToolbarHeight() {
                    // 動的調整機能を削除し、静的な高さを設定
                    const toolbar = this.elements.toolbar;
                    toolbar.style.height = '350px'; // 12個分のボタンに適した高さ
                    toolbar.style.overflow = 'hidden';

                    logMessage('ツールバー高さを静的に設定: 350px');
                },
                toggleWindow() {
                    if (!state.window) {
                        const id = 'single-window';
                        const savedState = GM_getValue(`windowState-${id}`, { position: { left: '21px', top: '23px' }, size: { width: '950px', height: '550px' } });
                        const windowObj = Window.create(id, savedState);
                        if (windowObj) { state.setWindow(windowObj); windowObj.el.style.display = 'none'; }
                    }
                    const windowEl = state.window.el;
                    windowEl.style.display = windowEl.style.display === 'none' ? 'block' : 'none';
                    if (windowEl.style.display === 'block') bringToFront(state.window);
                    Window.saveState(state.window);
                    this.elements.toggleWindowButton.textContent = windowEl.style.display === 'block' ? '🔽' : '🖼️';
                }
            };

            const Window = {
                colorPresets: new Map([['赤', '#8B0000'], ['青', '#1E90FF'], ['黄色', '#DAA520'], ['緑', '#228B22'], ['ピンク', '#C71585'], ['オレンジ', '#FF4500'], ['紫', '#4B0082'], ['茶色', '#8B4513'], ['灰色', '#696969']]),
                thumbnailPresets: ['🌟', '📌', '📷', '📖', '🎵'],
                create(id, savedState) {
                    try {
                        const el = document.createElement('div');
                        el.className = 'window';
                        el.id = `window-${id}`;
                        const fragment = document.createDocumentFragment();

                        const windowObj = {
                            el, id, name: savedState?.name || '1', activeTab: savedState?.activeTab || [...state.customTabs][0],
                            isMaximized: savedState?.isMaximized || false,
                            sortOrder: savedState?.sortOrder || 'newest',
                            layout: savedState?.layout || 'tile',
                            itemSize: savedState?.itemSize || 'standard',
                            displayMode: savedState?.displayMode || 'full',
                            position: savedState?.position || { left: '21px', top: '23px' },
                            size: savedState?.size || { width: '950px', height: '550px' },
                            isEditing: savedState?.isEditing || false
                        };

                        // 初期化時にアクティブタブの設定を読み込む
                        windowObj.sortOrder = GM_getValue(`sortOrder-${windowObj.activeTab}`, windowObj.sortOrder);
                        windowObj.layout = GM_getValue(`layout-${windowObj.activeTab}`, windowObj.layout);
                        windowObj.itemSize = GM_getValue(`itemSize-${windowObj.activeTab}`, windowObj.itemSize);
                        windowObj.displayMode = GM_getValue(`displayMode-${windowObj.activeTab}`, windowObj.displayMode);
                        windowObj.multiSelectMode = GM_getValue(`multiSelectMode-${windowObj.activeTab}`, false);

                        // 選択されたタグを読み込む
                        const savedSelectedTags = GM_getValue(`selectedTags-${windowObj.activeTab}`, []);
                        windowObj.selectedTags = new Set(savedSelectedTags);

                        // 除外タグを読み込む
                        windowObj.excludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);

                        // タググループを読み込む
                        windowObj.tagGroups = GM_getValue(`tagGroups-${windowObj.activeTab}`, {});

                        const toolbarHandle = document.createElement('div'); toolbarHandle.className = 'toolbarHandle';
                        const menuBar = document.createElement('div'); menuBar.className = 'menuBar';
                        const leftButtons = document.createElement('div'); leftButtons.className = 'left-buttons';
                        const tabMenuBtn = document.createElement('button'); tabMenuBtn.className = 'tabMenuButton'; tabMenuBtn.textContent = 'タブ';
                        const windowMenuBtn = document.createElement('button'); windowMenuBtn.className = 'windowMenuButton'; windowMenuBtn.textContent = 'ウィンドウ';
                        const itemMenuBtn = document.createElement('button'); itemMenuBtn.className = 'itemMenuButton'; itemMenuBtn.textContent = 'アイテム';
                        const dataMenuBtn = document.createElement('button'); dataMenuBtn.className = 'dataMenuButton'; dataMenuBtn.textContent = 'データ';
                        leftButtons.append(tabMenuBtn, windowMenuBtn, itemMenuBtn, dataMenuBtn);
                        const title = document.createElement('h3'); title.textContent = windowObj.name;
                        const rightButtons = document.createElement('div'); rightButtons.className = 'right-buttons';
                        const debugInfo = document.createElement('span'); debugInfo.className = 'debug-info';
                        const minimizeBtn = document.createElement('button'); minimizeBtn.className = 'minimizeButton'; minimizeBtn.textContent = '─';
                        const maximizeBtn = document.createElement('button'); maximizeBtn.className = 'maximizeButton'; maximizeBtn.textContent = '□';
                        rightButtons.append(debugInfo, minimizeBtn, maximizeBtn);
                        menuBar.append(leftButtons, title, rightButtons);

                        const controlBar = document.createElement('div'); controlBar.className = 'controlBar';
                        const editBtn = document.createElement('button'); editBtn.className = 'editButton'; editBtn.textContent = '編集';
                        const layoutBtn = document.createElement('button'); layoutBtn.className = 'layoutButton'; layoutBtn.textContent = 'タイル';
                        const sortSelect = document.createElement('select'); sortSelect.className = 'sortSelect';
                        ['newest:新しい順', 'oldest:古い順', 'extractedDateOldest:抽出日付 古い順', 'extractedDateNewest:抽出日付 新しい順'].forEach(opt => {
                            const option = document.createElement('option');
                            const [value, text] = opt.split(':');
                            option.value = value;
                            option.textContent = text;
                            sortSelect.appendChild(option);
                        });
                        const itemSizeSelect = document.createElement('select'); itemSizeSelect.className = 'itemSizeSelect';
                        ['standard:標準', 'large:大', 'medium:中', 'small:小', 'half:1/2', 'third:1/3', 'quarter:1/4', 'mini:ミニ'].forEach(opt => {
                            const option = document.createElement('option');
                            const [value, text] = opt.split(':');
                            option.value = value;
                            option.textContent = text;
                            itemSizeSelect.appendChild(option);
                        });
                        const displayModeSelect = document.createElement('select'); displayModeSelect.className = 'displayModeSelect';
                        ['full:すべて表示', 'image-only:画像のみ', 'image-title:画像とタイトル'].forEach(opt => {
                            const option = document.createElement('option');
                            const [value, text] = opt.split(':');
                            option.value = value;
                            option.textContent = text;
                            displayModeSelect.appendChild(option);
                        });
                        const dataSizeBtn = document.createElement('button'); dataSizeBtn.className = 'dataSizeButton'; dataSizeBtn.textContent = 'データ';
                        const elementEditBtn = document.createElement('button'); elementEditBtn.className = 'elementEditButton'; elementEditBtn.textContent = '要素編集'; elementEditBtn.title = '要素編集';
                        const tagEditBtn = document.createElement('button'); tagEditBtn.className = 'tagEditButton'; tagEditBtn.textContent = 'タグ編集'; tagEditBtn.title = 'タグ編集';
                        const multiSelectBtn = document.createElement('button'); multiSelectBtn.className = 'multiSelectButton'; multiSelectBtn.textContent = '☑️'; multiSelectBtn.title = '複数選択モード';
                        const tagFilterArea = document.createElement('div'); tagFilterArea.className = 'tagFilterArea'; tagFilterArea.style.cssText = 'display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; padding: 5px; background: #0a1f2e; border-radius: 5px; min-height: 30px;';
                        controlBar.append(editBtn, layoutBtn, sortSelect, itemSizeSelect, displayModeSelect, dataSizeBtn, elementEditBtn, tagEditBtn, multiSelectBtn, tagFilterArea);

                        const tabSidebar = document.createElement('div'); tabSidebar.className = 'tabSidebar';
                        const savedItems = document.createElement('div'); savedItems.className = 'savedItems';
                        const resizeTop = document.createElement('div'); resizeTop.className = 'resize-handle resize-top';
                        const resizeBottom = document.createElement('div'); resizeBottom.className = 'resize-handle resize-bottom';
                        const resizeLeft = document.createElement('div'); resizeLeft.className = 'resize-handle resize-left';
                        const resizeRight = document.createElement('div'); resizeRight.className = 'resize-handle resize-right';

                        fragment.append(toolbarHandle, menuBar, controlBar, tabSidebar, savedItems, resizeTop, resizeBottom, resizeLeft, resizeRight);
                        el.appendChild(fragment);
                        document.body.appendChild(el);

                        logMessage(`ウィンドウ ${id} 追加成功`);
                        this.setupEventListeners(windowObj);
                        updateTabs(windowObj);
                        displaySavedItems(windowObj);
                        el.style.left = windowObj.position.left;
                        el.style.top = windowObj.position.top;
                        el.style.width = windowObj.size.width;
                        el.style.height = windowObj.size.height;
                        el.style.display = 'none';
                        return windowObj;
                    } catch (e) {
                        logMessage(`ウィンドウ ${id} 作成失敗: ${e.message}`);
                        return null;
                    }
                },
                setupEventListeners(windowObj) {
                    const toolbarHandle = windowObj.el.querySelector('.toolbarHandle'), minimizeButton = windowObj.el.querySelector('.minimizeButton'), maximizeButton = windowObj.el.querySelector('.maximizeButton'), tabMenuButton = windowObj.el.querySelector('.tabMenuButton'), windowMenuButton = windowObj.el.querySelector('.windowMenuButton'), itemMenuButton = windowObj.el.querySelector('.itemMenuButton'), dataMenuButton = windowObj.el.querySelector('.dataMenuButton'), menuBar = windowObj.el.querySelector('.menuBar'), editButton = windowObj.el.querySelector('.editButton'), layoutButton = windowObj.el.querySelector('.layoutButton'), sortSelect = windowObj.el.querySelector('.sortSelect'), itemSizeSelect = windowObj.el.querySelector('.itemSizeSelect'), displayModeSelect = windowObj.el.querySelector('.displayModeSelect'), savedItems = windowObj.el.querySelector('.savedItems'), controlBar = windowObj.el.querySelector('.controlBar'), debugInfo = windowObj.el.querySelector('.debug-info');
                    sortSelect.value = windowObj.sortOrder; events.add(sortSelect, 'change', () => { windowObj.sortOrder = sortSelect.value; GM_setValue(`sortOrder-${windowObj.activeTab}`, windowObj.sortOrder); displaySavedItems(windowObj); this.saveState(windowObj); });
                    itemSizeSelect.value = windowObj.itemSize; events.add(itemSizeSelect, 'change', () => { windowObj.itemSize = itemSizeSelect.value; GM_setValue(`itemSize-${windowObj.activeTab}`, windowObj.itemSize); displaySavedItems(windowObj); this.saveState(windowObj); });
                    displayModeSelect.value = windowObj.displayMode; events.add(displayModeSelect, 'change', () => { windowObj.displayMode = displayModeSelect.value; GM_setValue(`displayMode-${windowObj.activeTab}`, windowObj.displayMode); displaySavedItems(windowObj); this.saveState(windowObj); });
                    events.add(windowObj.el, 'mousedown', () => { bringToFront(windowObj); if (state.activeMenu && !menuBar.contains(event.target) && !state.activeMenu.contains(event.target)) { closeActiveMenu(); state.isHoverEnabled = false; } });
                    const updateDebugInfo = () => debugInfo.textContent = `(${windowObj.el.style.left}, ${windowObj.el.style.top}) ${windowObj.el.style.width}x${windowObj.el.style.height}`; updateDebugInfo();
                    let isDragging = false, offsetX, offsetY;
                    const handleDragMove = (e) => { if (isDragging) { let leftPx = e.clientX - offsetX; let topPx = e.clientY - offsetY; let widthPx = parseInt(windowObj.el.style.width); let heightPx = parseInt(windowObj.el.style.height); leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - widthPx)); topPx = Math.max(0, Math.min(topPx, window.innerHeight - heightPx - 40)); requestAnimationFrame(() => { windowObj.el.style.left = `${leftPx}px`; windowObj.el.style.top = `${topPx}px`; }); } };
                    const handleDragEnd = () => { if (isDragging) { this.saveState(windowObj); isDragging = false; document.removeEventListener('mousemove', handleDragMove); document.removeEventListener('mouseup', handleDragEnd); } };
                    events.add(toolbarHandle, 'mousedown', (e) => { isDragging = true; offsetX = e.clientX - windowObj.el.offsetLeft; offsetY = e.clientY - windowObj.el.offsetTop; e.preventDefault(); document.addEventListener('mousemove', handleDragMove); document.addEventListener('mouseup', handleDragEnd); });
                    let isResizing = false, resizeDir, startX, startY, startWidth, startHeight, startLeft, startTop;
                    const handleResizeMove = (e) => {
                        if (!isResizing) return; let deltaX = e.clientX - startX; let deltaY = e.clientY - startY; let newWidth = startWidth; let newHeight = startHeight; let newLeft = startLeft; let newTop = startTop;
                        if (resizeDir === 'top') { newHeight = startHeight - deltaY; newTop = startTop + deltaY; } else if (resizeDir === 'bottom') { newHeight = startHeight + deltaY; } else if (resizeDir === 'left') { newWidth = startWidth - deltaX; newLeft = startLeft + deltaX; } else if (resizeDir === 'right') { newWidth = startWidth + deltaX; }
                        newWidth = Math.max(200, Math.min(newWidth, window.innerWidth - newLeft)); newHeight = Math.max(150, Math.min(newHeight, window.innerHeight - newTop - 40)); newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - newWidth)); newTop = Math.max(0, Math.min(newTop, window.innerHeight - newHeight - 40));
                        requestAnimationFrame(() => { windowObj.el.style.width = `${newWidth}px`; windowObj.el.style.height = `${newHeight}px`; windowObj.el.style.left = `${newLeft}px`; windowObj.el.style.top = `${newTop}px`; });
                    };
                    const handleResizeEnd = () => { if (isResizing) { this.saveState(windowObj); isResizing = false; document.removeEventListener('mousemove', handleResizeMove); document.removeEventListener('mouseup', handleResizeEnd); } };
                    ['top', 'bottom', 'left', 'right'].forEach(dir => { const handle = windowObj.el.querySelector(`.resize-${dir}`); events.add(handle, 'mousedown', (e) => { isResizing = true; resizeDir = dir; startX = e.clientX; startY = e.clientY; startWidth = parseInt(windowObj.el.style.width); startHeight = parseInt(windowObj.el.style.height); startLeft = parseFloat(windowObj.el.style.left); startTop = parseFloat(windowObj.el.style.top); e.preventDefault(); document.addEventListener('mousemove', handleResizeMove); document.addEventListener('mouseup', handleResizeEnd); }); });
                    events.add(savedItems, 'wheel', (e) => { e.preventDefault(); savedItems.scrollTop += e.deltaY; });
                    events.add(minimizeButton, 'click', () => { windowObj.el.style.display = 'none'; this.saveState(windowObj); Toolbar.elements.toggleWindowButton.textContent = '🖼️'; });
                    events.add(maximizeButton, 'click', () => {
                        if (!windowObj.isMaximized) { windowObj.size = { width: windowObj.el.style.width, height: windowObj.el.style.height }; windowObj.el.style.width = `${window.innerWidth}px`; windowObj.el.style.height = `${window.innerHeight - 40}px`; windowObj.el.style.top = '0'; windowObj.el.style.left = '0'; maximizeButton.textContent = '🗗'; } else { windowObj.el.style.width = windowObj.size.width; windowObj.el.style.height = windowObj.size.height; windowObj.el.style.top = windowObj.position.top; windowObj.el.style.left = windowObj.position.left; maximizeButton.textContent = '□'; }
                        windowObj.isMaximized = !windowObj.isMaximized; this.saveState(windowObj);
                    });
                    const dataSizeButton = windowObj.el.querySelector('.dataSizeButton');
                    const menuButtons = [{ button: tabMenuButton, type: 'tab' }, { button: windowMenuButton, type: 'window' }, { button: itemMenuButton, type: 'item' }, { button: dataMenuButton, type: 'data' }];
                    menuButtons.forEach(menu => {
                        events.add(menu.button, 'click', (e) => {
                            e.preventDefault(); e.stopPropagation();
                            if (state.isHoverEnabled) { closeActiveMenu(); state.isHoverEnabled = false; logMessage('ホバー状態を解除しました（メニューバー再クリック）'); } else { closeActiveMenu(); state.isHoverEnabled = true; state.activeMenu = this.createSubMenu(windowObj, menu.type, menu.button); addCloseOnClickOutside(state.activeMenu, menuBar); logMessage(`メニューを開きました: ${menu.type}`); }
                        });
                        events.add(menu.button, 'mouseenter', () => { if (state.isHoverEnabled && !state.activePopup) { closeActiveMenu(); state.activeMenu = this.createSubMenu(windowObj, menu.type, menu.button); addCloseOnClickOutside(state.activeMenu, menuBar); logMessage(`ホバーでメニューを開きました: ${menu.type}`); } });
                    });
                        events.add(editButton, 'click', () => {
                                        if (windowObj.isEditing) {
                            // 編集モード終了
                            controlBar.querySelectorAll('.moveTabButton, .selectAll, .deselectAll, .deleteSelected, .resizeSelected').forEach(btn => btn.remove());
                            editButton.textContent = '編集';
                            windowObj.isEditing = false;
                            windowObj.el.classList.remove('editing');
                            savedItems.querySelectorAll('.savedItem').forEach(item => {
                                events.removeAll(item); // 既存のクリックイベントをクリア
                                item.style.cursor = 'pointer';
                                item.classList.remove('selected');
                                const checkbox = item.querySelector('.selectItem');
                                if (checkbox) {
                                    checkbox.checked = false;
                                    checkbox.remove(); // チェックボックスを削除
                                }
                            });
                            logMessage(`編集モード終了: ${windowObj.id}`);
                } else {
                    // 編集モード開始
                    const moveTabBtn = document.createElement('button');
                    moveTabBtn.className = 'moveTabButton';
                    moveTabBtn.textContent = '➡';
                    events.add(moveTabBtn, 'click', () => {
                        const checkboxes = savedItems.querySelectorAll('.selectItem:checked');
                        if (!checkboxes.length) return;
                        if (state.activePopup) {
                            state.activePopup.remove();
                            state.activePopup = null;
                        }
                        state.activePopup = createMoveTabWindow(windowObj, checkboxes);
                    });
                    const selectAllBtn = document.createElement('button');
                    selectAllBtn.className = 'selectAll';
                    selectAllBtn.textContent = '全選択';
                    events.add(selectAllBtn, 'click', () => {
                        savedItems.querySelectorAll('.selectItem').forEach(cb => {
                            cb.checked = true;
                            cb.parentElement.classList.add('selected');
                        });
                    });
                    const deselectAllBtn = document.createElement('button');
                    deselectAllBtn.className = 'deselectAll';
                    deselectAllBtn.textContent = '全解除';
                    events.add(deselectAllBtn, 'click', () => {
                        savedItems.querySelectorAll('.selectItem').forEach(cb => {
                            cb.checked = false;
                            cb.parentElement.classList.remove('selected');
                        });
                    });
                    const deleteSelectedBtn = document.createElement('button');
                    deleteSelectedBtn.className = 'deleteSelected';
                    deleteSelectedBtn.textContent = '🗑️';
                    events.add(deleteSelectedBtn, 'click', () => {
                        const checkboxes = savedItems.querySelectorAll('.selectItem:checked');
                        if (!checkboxes.length) return;
                        let allItems = GM_getValue('savedItems', []);
                        checkboxes.forEach(cb => {
                            const timestamp = cb.parentElement.dataset.timestamp;
                            allItems = allItems.filter(item => item.timestamp !== timestamp);
                        });
                        GM_setValue('savedItems', allItems);
                        displaySavedItems(windowObj);
                    });

                    const resizeSelectedBtn = document.createElement('button');
                    resizeSelectedBtn.className = 'resizeSelected';
                    resizeSelectedBtn.textContent = '📏';
                    resizeSelectedBtn.title = '選択した画像をリサイズ';
                    events.add(resizeSelectedBtn, 'click', () => {
                        const checkboxes = savedItems.querySelectorAll('.selectItem:checked');
                        if (!checkboxes.length) {
                            alert('リサイズする画像を選択してください。');
                            return;
                        }
                        if (confirm(`選択した${checkboxes.length}件の画像を150x150px以下にリサイズしますか？\n※元の画像は復元できません。`)) {
                            resizeSelectedImages(windowObj, checkboxes);
                        }
                    });
                    controlBar.insertBefore(moveTabBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(selectAllBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(deselectAllBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(deleteSelectedBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(resizeSelectedBtn, controlBar.querySelector('.layoutButton'));
                    editButton.textContent = '終了';
                    windowObj.isEditing = true;
                    windowObj.el.classList.add('editing');
                    // 既存のアイテムにチェックボックスを追加
                    savedItems.querySelectorAll('.savedItem').forEach(item => {
                        if (!item.querySelector('.selectItem')) {
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'selectItem';
                            checkbox.style.display = 'block';
                            item.insertBefore(checkbox, item.firstChild);
                        }
                    });
                    addItemClickListeners(windowObj, savedItems.querySelectorAll('.savedItem'));
                    logMessage(`編集モード開始: ${windowObj.id}`);
                }
            });
                        events.add(layoutButton, 'click', () => {
                        windowObj.layout = windowObj.layout === 'tile' ? 'column' : 'tile';
                        GM_setValue(`layout-${windowObj.activeTab}`, windowObj.layout);
                        layoutButton.textContent = windowObj.layout === 'tile' ? 'タイル' : '1列';
                        displaySavedItems(windowObj);
                        this.saveState(windowObj);
                    });
                    layoutButton.textContent = windowObj.layout === 'tile' ? 'タイル' : '1列';
                    events.add(dataSizeButton, 'click', () => showDataSizeInfo(windowObj));
                    const elementEditButton = windowObj.el.querySelector('.elementEditButton');
                    events.add(elementEditButton, 'click', () => createElementEditWindow(windowObj));
                    const tagEditButton = windowObj.el.querySelector('.tagEditButton');
                    events.add(tagEditButton, 'click', () => createTagEditWindow(windowObj));

                    const multiSelectButton = windowObj.el.querySelector('.multiSelectButton');
                    events.add(multiSelectButton, 'click', () => {
                        if (windowObj.multiSelectMode) {
                            // 複数選択モード終了
                            windowObj.multiSelectMode = false;
                            multiSelectButton.style.background = '#104437';
                            multiSelectButton.textContent = '☑️';
                            GM_setValue(`multiSelectMode-${windowObj.activeTab}`, false);
                            // チェックボックスを削除
                            const savedItems = windowObj.el.querySelector('.savedItems');
                            savedItems.querySelectorAll('.savedItem').forEach(item => {
                                const checkbox = item.querySelector('.selectItem');
                                if (checkbox) {
                                    checkbox.checked = false;
                                    checkbox.remove();
                                }
                                item.classList.remove('selected');
                            });
                            logMessage('複数選択モード終了');
                        } else {
                            // 複数選択モード開始
                            windowObj.multiSelectMode = true;
                            multiSelectButton.style.background = '#e67e22';
                            multiSelectButton.textContent = '☑️';
                            GM_setValue(`multiSelectMode-${windowObj.activeTab}`, true);
                            // 既存のアイテムにチェックボックスを追加
                            const savedItems = windowObj.el.querySelector('.savedItems');
                            savedItems.querySelectorAll('.savedItem').forEach(item => {
                                if (!item.querySelector('.selectItem')) {
                                    const checkbox = document.createElement('input');
                                    checkbox.type = 'checkbox';
                                    checkbox.className = 'selectItem';
                                    checkbox.style.display = 'block';
                                    item.insertBefore(checkbox, item.firstChild);
                                }
                            });
                            addItemClickListeners(windowObj, savedItems.querySelectorAll('.savedItem'));
                            logMessage('複数選択モード開始');
                        }
                    });

                    // 初期クリアボタンの設定
                    updateClearButton(windowObj);

                    logMessage(`ウィンドウ ${windowObj.id} リスナー設定完了`);
                },
                createSubMenu(windowObj, type, button) {
                    const subMenu = document.createElement('div'); subMenu.className = 'subMenu';
                    const menuBar = button.closest('.menuBar');
                    const menuBarRect = menuBar.getBoundingClientRect();
                    const buttonRect = button.getBoundingClientRect();
                    const windowRect = windowObj.el.getBoundingClientRect();
                    subMenu.style.position = 'absolute'; subMenu.style.left = `${buttonRect.left - windowRect.left}px`; subMenu.style.top = `${menuBarRect.height}px`;
                    const items = type === 'tab' ? [{ text: 'タブ管理', action: () => createTabManageWindow(windowObj) }] :
                                type === 'window' ? [] :
                                type === 'item' ? [{ text: 'すべてのアイテムを削除', action: () => { if (confirm('すべてのアイテムを削除しますか？')) { GM_setValue('savedItems', []); displaySavedItems(windowObj); } } }] :
                                type === 'data' ? [
                                    { text: '📤 エクスポート', action: () => Toolbar.exportItems() },
                                    { text: '📥 インポート', action: () => Toolbar.importItems() },
                                    { text: '📊 ログ表示', action: () => createLogWindow() }
                                ] : [];
                    items.forEach(item => {
                        const menuItem = document.createElement('div'); menuItem.textContent = item.text; menuItem.className = 'subMenuItem';
                        events.add(menuItem, 'click', (e) => { e.stopPropagation(); closeActiveMenu(); if (state.activePopup) { state.activePopup.remove(); state.activePopup = null; } state.activePopup = item.action(); bringToFrontPopup(state.activePopup); });
                        events.add(menuItem, 'mouseenter', () => menuItem.style.backgroundColor = '#ddd');
                        events.add(menuItem, 'mouseleave', () => menuItem.style.backgroundColor = '#f0f0f0');
                        subMenu.appendChild(menuItem);
                    });
                    windowObj.el.appendChild(subMenu);
                    return subMenu;
                },
                saveState(windowObj) {
                    const savedState = {
                        name: windowObj.name, activeTab: windowObj.activeTab, isMaximized: windowObj.isMaximized,
                        sortOrder: windowObj.sortOrder, layout: windowObj.layout, itemSize: windowObj.itemSize,
                        displayMode: windowObj.displayMode, isEditing: windowObj.isEditing,
                        position: { left: windowObj.el.style.left, top: windowObj.el.style.top },
                        size: { width: windowObj.el.style.width, height: windowObj.el.style.height },
                        display: windowObj.el.style.display
                    };
                    GM_setValue(`windowState-${windowObj.id}`, savedState);
                }
            };

            const saveImage = () => {
                if (!state.currentCompressedImage || !state.window) { logMessage('保存失敗: 画像なしまたはウィンドウなし'); return; }
                const domain = window.location.hostname; const { tags, extractedDate } = extractTagsAndDate(); const favicon = getFaviconForNewTab(domain, window.location.href); const savedData = { image: state.currentCompressedImage, url: window.location.href, title: document.title, favicon, timestamp: getTimestamp(), tab: domain, tags, extractedDate };
                const allItems = GM_getValue('savedItems', []); allItems.push(savedData); GM_setValue('savedItems', allItems); state.window.activeTab = domain; updateTabs(state.window); displaySavedItems(state.window); logMessage('画像とタグ、日付保存成功');
            };

            const extractTagsAndDate = () => {
                const tags = new Set(); let extractedDate = null;
                const domain = window.location.hostname;

                // ドメイン別のセレクター設定を取得（デフォルトは元の固定セレクター）
                const defaultSelectors = {
                    tagSelector: 'div.q-chip',
                    tagContentSelector: '.q-chip__content',
                    dateSelector: 'div.absolute-bottom-right'
                };

                const customSelectors = state.elementSelectors.get(domain) || defaultSelectors;

                // タグ要素の抽出
                document.querySelectorAll(customSelectors.tagSelector).forEach(el => {
                    let content = el;
                    if (customSelectors.tagContentSelector) {
                        content = el.querySelector(customSelectors.tagContentSelector);
                    }
                    if (content && content.textContent.trim()) {
                        const tagText = content.textContent.trim();
                        if (tagText.length > 0 && tagText.length < 20) tags.add(tagText);
                    }
                });

                // 日付要素の抽出
                const dateElement = document.querySelector(customSelectors.dateSelector);
                if (dateElement && dateElement.textContent.trim()) {
                    extractedDate = dateElement.textContent.trim();
                }

                // 除外タグをフィルタリング
                const excludeTags = GM_getValue(`excludeTags-${domain}`, []);
                const filteredTags = [...tags].filter(tag => {
                    return !excludeTags.some(excludeRule => {
                        if (excludeRule.type === 'regex') {
                            try {
                                return new RegExp(excludeRule.pattern).test(tag);
                            } catch (e) {
                                return false;
                            }
                        } else {
                            return excludeRule.pattern === tag;
                        }
                    });
                });

                const excludedCount = tags.size - filteredTags.length;
                logMessage(`タグ抽出完了: ${filteredTags.length}個 (${filteredTags.join(', ')}), 除外: ${excludedCount}個, 日付: ${extractedDate || 'なし'}`);
                return { tags: filteredTags, extractedDate };
            };

            const getFaviconForNewTab = (tab, url) => {
                const allItems = GM_getValue('savedItems', []); const existingTab = allItems.find(item => item.tab === tab);
                if (existingTab) { logMessage(`既存タブ ${tab} のファビコンを再利用`); return existingTab.favicon; }
                const favicon = document.querySelector('link[rel="icon"]')?.href || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><circle cx="8" cy="8" r="7" fill="#104437"/></svg>';
                logMessage(`ファビコン取得: ${favicon}`); return favicon;
            };

            const cleanDomainName = (domain) => {
                // Remove common prefixes like www, m, mobile, etc.
                const prefixes = ['www.', 'm.', 'mobile.', 'app.', 'api.'];
                let cleaned = domain.toLowerCase();
                for (const prefix of prefixes) {
                    if (cleaned.startsWith(prefix)) {
                        cleaned = cleaned.substring(prefix.length);
                        break;
                    }
                }
                return cleaned;
            };

            const updateTabs = (windowObj) => {
                const tabSidebar = windowObj.el.querySelector('.tabSidebar'); tabSidebar.innerHTML = '';
                const allItems = GM_getValue('savedItems', []); const autoTabs = new Set(allItems.map(item => item.tab).filter(t => !state.customTabs.has(t))); const allTabs = [...state.customTabs, ...autoTabs];
                const domainDisplayMode = GM_getValue('domainDisplayMode', false);

                allTabs.forEach(tab => {
                    const tabButton = document.createElement('button'); tabButton.className = 'tab-vertical'; tabButton.dataset.tab = tab;
                    const favicon = allItems.find(item => item.tab === tab)?.favicon;

                    // ドメイン名表示設定に応じてタブの表示を変更
                    const showDomainName = state.tabDomainNames.get(tab);
                    if (showDomainName && !state.customTabs.has(tab) && !state.tabThumbnails.has(tab)) {
                        // ドメイン名を表示（wwwなどを除去、文字を大きく、ファビコンを追加）
                        const cleanedDomain = cleanDomainName(tab);

                        // ドメイン名のテキスト
                        const domainSpan = document.createElement('span');
                        domainSpan.textContent = cleanedDomain;
                        domainSpan.style.cssText = `
                            font-size: 11px;
                            font-weight: bold;
                            color: white;
                            text-align: center;
                            line-height: 1.2;
                            word-break: break-all;
                            margin-bottom: 2px;
                        `;

                        // ファビコン
                        if (favicon) {
                            const faviconImg = document.createElement('img');
                            faviconImg.src = favicon;
                            faviconImg.style.cssText = `
                                width: 16px;
                                height: 16px;
                                border-radius: 2px;
                                margin-top: 2px;
                            `;
                            faviconImg.onerror = function() { this.style.display = 'none'; };
                            tabButton.appendChild(domainSpan);
                            tabButton.appendChild(faviconImg);
                        } else {
                            tabButton.appendChild(domainSpan);
                        }
                    } else {
                        // 従来の表示（ファビコンまたはサムネイル）
                        if (favicon && !state.customTabs.has(tab) && !state.tabThumbnails.has(tab)) {
                            const faviconImg = document.createElement('img');
                            faviconImg.src = favicon;
                            faviconImg.onerror = function() { this.style.display = 'none'; };
                            tabButton.appendChild(faviconImg);
                        } else {
                            const span = document.createElement('span');
                            span.textContent = state.tabThumbnails.get(tab) || tab[0];
                            tabButton.appendChild(span);
                        }
                    }

                    tabButton.style.backgroundColor = state.tabColors.get(tab) || '#104437'; tabButton.title = tab;
                    events.add(tabButton, 'click', () => {
                        // 即座にUIを更新してレスポンシブ性を向上
                        tabSidebar.querySelectorAll('.tab-vertical').forEach(t => t.classList.remove('active'));
                        tabButton.classList.add('active');
                        bringToFront(windowObj);

                        // 非同期でタブ切り替え処理を実行
                        requestAnimationFrame(() => {
                            windowObj.activeTab = tab;
                            GM_setValue(`activeTab-${windowObj.id}`, tab);

                            // タブ切り替え時にドメイン別の設定を読み込む
                            if (tab !== 'メモ' && !state.customTabs.has(tab)) {
                                // ドメイン別の設定を読み込む
                                windowObj.sortOrder = GM_getValue(`sortOrder-${tab}`, 'newest');
                                windowObj.layout = GM_getValue(`layout-${tab}`, 'tile');
                                windowObj.itemSize = GM_getValue(`itemSize-${tab}`, 'standard');
                                windowObj.displayMode = GM_getValue(`displayMode-${tab}`, 'full');
                            } else {
                                // カスタムタブの場合はデフォルト設定を使用
                                windowObj.sortOrder = GM_getValue(`sortOrder-${tab}`, 'newest');
                                windowObj.layout = GM_getValue(`layout-${tab}`, 'tile');
                                windowObj.itemSize = GM_getValue(`itemSize-${tab}`, 'standard');
                                windowObj.displayMode = GM_getValue(`displayMode-${tab}`, 'full');
                            }

                            // 選択されたタグを読み込む
                            const savedSelectedTags = GM_getValue(`selectedTags-${tab}`, []);
                            windowObj.selectedTags = new Set(savedSelectedTags);

                            // 除外タグを読み込む（表示用）
                            windowObj.excludeTags = GM_getValue(`excludeTags-${tab}`, []);

                            // タググループを読み込む（表示用）
                            windowObj.tagGroups = GM_getValue(`tagGroups-${tab}`, {});

                            // 複数選択モードの状態を読み込む
                            windowObj.multiSelectMode = GM_getValue(`multiSelectMode-${tab}`, false);

                            // UIを更新
                            const sortSelect = windowObj.el.querySelector('.sortSelect');
                            const layoutButton = windowObj.el.querySelector('.layoutButton');
                            const itemSizeSelect = windowObj.el.querySelector('.itemSizeSelect');
                            const displayModeSelect = windowObj.el.querySelector('.displayModeSelect');
                            const multiSelectButton = windowObj.el.querySelector('.multiSelectButton');

                            if (sortSelect) sortSelect.value = windowObj.sortOrder;
                            if (layoutButton) layoutButton.textContent = windowObj.layout === 'tile' ? 'タイル' : '1列';
                            if (itemSizeSelect) itemSizeSelect.value = windowObj.itemSize;
                            if (displayModeSelect) displayModeSelect.value = windowObj.displayMode;
                            if (multiSelectButton) {
                                if (windowObj.multiSelectMode) {
                                    multiSelectButton.style.background = '#e67e22';
                                    // 複数選択モードが有効な場合、既存のアイテムにチェックボックスを追加
                                    const savedItems = windowObj.el.querySelector('.savedItems');
                                    if (savedItems) {
                                        savedItems.querySelectorAll('.savedItem').forEach(item => {
                                            if (!item.querySelector('.selectItem')) {
                                                const checkbox = document.createElement('input');
                                                checkbox.type = 'checkbox';
                                                checkbox.className = 'selectItem';
                                                checkbox.style.display = 'block';
                                                item.insertBefore(checkbox, item.firstChild);
                                            }
                                        });
                                        addItemClickListeners(windowObj, savedItems.querySelectorAll('.savedItem'));
                                    }
                                } else {
                                    multiSelectButton.style.background = '#104437';
                                }
                            }

                            // アイテム表示を非同期で実行
                            setTimeout(() => {
                                displaySavedItems(windowObj);
                                // 編集モードが有効な場合、チェックボックスを追加
                                if (windowObj.isEditing) {
                                    const savedItems = windowObj.el.querySelector('.savedItems');
                                    if (savedItems) {
                                        savedItems.querySelectorAll('.savedItem').forEach(item => {
                                            if (!item.querySelector('.selectItem')) {
                                                const checkbox = document.createElement('input');
                                                checkbox.type = 'checkbox';
                                                checkbox.className = 'selectItem';
                                                checkbox.style.display = 'block';
                                                item.insertBefore(checkbox, item.firstChild);
                                            }
                                        });
                                        addItemClickListeners(windowObj, savedItems.querySelectorAll('.savedItem'));
                                    }
                                }
                                Window.saveState(windowObj);
                            }, 0);
                        });
                    });
                    tabSidebar.appendChild(tabButton);
                    if (tab === windowObj.activeTab) tabButton.classList.add('active');
                });
            };

            // アイテム要素を作成する関数
            const createItemElement = (item, itemsDiv, windowObj) => {
                const a = document.createElement('a');
                a.href = item.url;
                a.target = '_blank';
                a.className = `savedItem ${windowObj.layout === 'column' ? 'column' : ''} size-${windowObj.itemSize} ${windowObj.displayMode === 'image-only' ? 'image-only' : ''} ${windowObj.displayMode === 'image-title' ? 'image-title' : ''}`;
                a.dataset.timestamp = item.timestamp;

                // 編集モードまたは複数選択モードの場合のみチェックボックスを作成
                if (windowObj.isEditing || windowObj.multiSelectMode) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'selectItem';
                    checkbox.style.display = 'block';
                    a.appendChild(checkbox);
                }

                const img = document.createElement('img');
                img.src = item.image;
                img.alt = '圧縮画像';
                a.appendChild(img);

                const titleP = document.createElement('p');
                const titleStrong = document.createElement('strong');
                titleStrong.textContent = ' ';
                titleP.appendChild(titleStrong);
                titleP.appendChild(document.createTextNode(item.title));
                a.appendChild(titleP);

                // データ量を計算して表示（fullモードのみ）
                if (windowObj.displayMode === 'full') {
                    const itemData = JSON.stringify(item);
                    const totalSize = new Blob([itemData]).size;
                    const imageSize = item.image ? new Blob([item.image]).size : 0;
                    const totalSizeKB = (totalSize / 1024).toFixed(1);
                    const imageSizeKB = (imageSize / 1024).toFixed(1);

                    const dataSizeP = document.createElement('p');
                    const dataSizeStrong = document.createElement('strong');
                    dataSizeStrong.textContent = 'データ量: ';
                    dataSizeP.appendChild(dataSizeStrong);
                    dataSizeP.appendChild(document.createTextNode(`${totalSizeKB}KB (画像: ${imageSizeKB}KB)`));
                    a.appendChild(dataSizeP);
                }

                if (windowObj.displayMode === 'full') {
                    const urlP = document.createElement('p');
                    const urlStrong = document.createElement('strong');
                    urlStrong.textContent = 'URL: ';
                    urlP.appendChild(urlStrong);
                    const urlSpan = document.createElement('span');
                    urlSpan.textContent = 'link';
                    urlP.appendChild(urlSpan);
                    a.appendChild(urlP);

                    const tagsP = document.createElement('p');
                    const tagsStrong = document.createElement('strong');
                    tagsStrong.textContent = 'タグ: ';
                    tagsP.appendChild(tagsStrong);
                    tagsP.appendChild(document.createTextNode(item.tags ? item.tags.join(', ') : 'なし'));
                    a.appendChild(tagsP);

                    const dateP = document.createElement('p');
                    const dateStrong = document.createElement('strong');
                    dateStrong.textContent = '抽出日付: ';
                    dateP.appendChild(dateStrong);
                    dateP.appendChild(document.createTextNode(item.extractedDate || 'なし'));
                    a.appendChild(dateP);

                    const saveDateP = document.createElement('p');
                    const saveDateStrong = document.createElement('strong');
                    saveDateStrong.textContent = '保存日時: ';
                    saveDateP.appendChild(saveDateStrong);
                    saveDateP.appendChild(document.createTextNode(new Date(item.timestamp).toLocaleString()));
                    a.appendChild(saveDateP);
                }

                itemsDiv.appendChild(a);
            };

            const displaySavedItems = (windowObj) => {
                const savedItems = GM_getValue('savedItems', []).filter(item => item.tab === windowObj.activeTab); let sortedItems = [...savedItems];
                if (windowObj.sortOrder === 'newest') sortedItems.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                else if (windowObj.sortOrder === 'oldest') sortedItems.sort((a, b) => new Date(a.timestamp) - new Date(a.timestamp));
                else if (windowObj.sortOrder === 'extractedDateOldest') { const itemsWithDate = sortedItems.filter(item => item.extractedDate); const itemsWithoutDate = sortedItems.filter(item => !item.extractedDate); itemsWithDate.sort((a, b) => new Date(a.extractedDate) - new Date(b.extractedDate)); sortedItems = [...itemsWithDate, ...itemsWithoutDate]; }
                else if (windowObj.sortOrder === 'extractedDateNewest') { const itemsWithDate = sortedItems.filter(item => item.extractedDate); const itemsWithoutDate = sortedItems.filter(item => !item.extractedDate); itemsWithDate.sort((a, b) => new Date(b.extractedDate) - new Date(a.extractedDate)); sortedItems = [...itemsWithDate, ...itemsWithoutDate]; }

                // タグフィルタリング
                const selectedTags = windowObj.selectedTags || new Set();
                if (selectedTags.size > 0) {
                    sortedItems = sortedItems.filter(item => {
                        if (!item.tags || !Array.isArray(item.tags)) return false;
                        return Array.from(selectedTags).every(tag => item.tags.includes(tag));
                    });
                }

                const itemsDiv = windowObj.el.querySelector('.savedItems');
                itemsDiv.className = `savedItems ${windowObj.layout === 'column' ? 'column' : ''}`;
                itemsDiv.innerHTML = '';

                // 大量のアイテムがある場合はバッチ処理で表示
                const batchSize = 50;
                const totalItems = sortedItems.length;

                if (totalItems > batchSize) {
                    // 最初のバッチを即座に表示
                    const firstBatch = sortedItems.slice(0, batchSize);
                    firstBatch.forEach(item => createItemElement(item, itemsDiv, windowObj));

                    // 残りのアイテムを非同期で表示
                    if (totalItems > batchSize) {
                        let currentIndex = batchSize;

                        const processNextBatch = () => {
                            const endIndex = Math.min(currentIndex + batchSize, totalItems);
                            const batch = sortedItems.slice(currentIndex, endIndex);

                            batch.forEach(item => createItemElement(item, itemsDiv, windowObj));

                            currentIndex = endIndex;

                            if (currentIndex < totalItems) {
                                // 次のバッチを非同期で処理
                                requestAnimationFrame(processNextBatch);
                            } else {
                                // すべて完了したらタグフィルターを更新
                                setTimeout(() => {
                                    updateTagFilterButtons(windowObj);
                                }, 0);
                            }
                        };

                        // 最初のバッチ処理を開始
                        setTimeout(processNextBatch, 0);
                    }
                } else {
                    // アイテム数が少ない場合は通常通り処理
                    sortedItems.forEach(item => createItemElement(item, itemsDiv, windowObj));

                    // タグボタンを更新（遅延実行でパフォーマンス改善）
                    setTimeout(() => {
                        updateTagFilterButtons(windowObj);
                    }, 0);
                }
                // 編集モードまたは複数選択モードの状態に応じてイベントリスナーを設定
                if (windowObj.isEditing || windowObj.multiSelectMode) {
                    addItemClickListeners(windowObj, itemsDiv.querySelectorAll('.savedItem'));
                } else {
                    itemsDiv.querySelectorAll('.savedItem').forEach(item => item.style.cursor = 'pointer');
                }

            };

            // アイテムクリックリスナーの設定
            const addItemClickListeners = (windowObj, items) => {
                items.forEach(item => {
                    events.removeAll(item); // 既存のイベントリスナーをクリア
                    item.style.cursor = 'pointer';
                    events.add(item, 'click', (e) => {
                        if (windowObj.isEditing || windowObj.multiSelectMode) {
                            e.preventDefault();
                            const checkbox = item.querySelector('.selectItem');
                            if (checkbox) {
                                checkbox.checked = !checkbox.checked;
                                item.classList.toggle('selected', checkbox.checked);
                                // アニメーションを追加
                                item.animate([
                                    { transform: 'scale(1)', backgroundColor: '#104437' },
                                    { transform: 'scale(1.05)', backgroundColor: '#16a085' },
                                    { transform: 'scale(1)', backgroundColor: '#104437' }
                                ], {
                                    duration: 200,
                                    easing: 'ease-in-out'
                                });
                                logMessage(`アイテムクリック: timestamp=${item.dataset.timestamp}, 選択状態=${checkbox.checked}`);
                            }
                        } else {
                            // 通常モードではリンクとして動作
                            const url = item.href;
                            if (url) {
                                window.open(url, '_blank');
                            }
                        }
                    });
                });
            };
            const createLogWindow = () => {
                let existingWindow = document.querySelector('#logWindow'); if (existingWindow) existingWindow.remove();
                const logWindow = document.createElement('div'); logWindow.id = 'logWindow';
                const menuBar = document.createElement('div'); menuBar.className = 'menuBar';
                const title = document.createElement('h3'); title.textContent = 'log';
                const closeBtn = document.createElement('button'); closeBtn.className = 'closeLog'; closeBtn.textContent = '×';
                menuBar.append(title, closeBtn);
                const logContent = document.createElement('div'); logContent.id = 'logContent';
                logWindow.append(menuBar, logContent);
                document.body.appendChild(logWindow);

                const toolbar = document.getElementById('toolbar'); if (toolbar) { logWindow.style.left = `${toolbar.offsetLeft / window.innerWidth * 100}vw`; logWindow.style.top = `${(toolbar.offsetTop + toolbar.offsetHeight + 10) / window.innerHeight * 100}vh`; }
                const debugOutput = document.getElementById('debugOutput'); if (debugOutput) { debugOutput.querySelectorAll('p').forEach(p => { const logP = document.createElement('p'); logP.textContent = p.textContent; logContent.appendChild(logP); }); logContent.scrollTop = logContent.scrollHeight; }
                let isDragging = false, offsetX, offsetY;
                const handleMouseMove = (e) => { if (isDragging) { let leftPx = e.clientX - offsetX; let topPx = e.clientY - offsetY; let widthPx = logWindow.offsetWidth; let heightPx = logWindow.offsetHeight; leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - widthPx)); topPx = Math.max(0, Math.min(topPx, window.innerHeight - heightPx)); requestAnimationFrame(() => { logWindow.style.left = `${leftPx}px`; logWindow.style.top = `${topPx}px`; }); } };
                const handleMouseUp = () => { if (isDragging) { isDragging = false; document.removeEventListener('mousemove', handleMouseMove); document.removeEventListener('mouseup', handleMouseUp); } };
                events.add(menuBar, 'mousedown', (e) => { if (e.target.tagName !== 'BUTTON') { isDragging = true; offsetX = e.clientX - logWindow.offsetLeft; offsetY = e.clientY - logWindow.offsetTop; e.preventDefault(); document.addEventListener('mousemove', handleMouseMove); document.addEventListener('mouseup', handleMouseUp); } });
                events.add(closeBtn, 'click', () => logWindow.remove());
                bringToFrontPopup(logWindow);
            };

            const createMoveTabWindow = (parentWindow, checkboxes) => {
                if (state.activePopup) { state.activePopup.remove(); state.activePopup = null; }
                const moveTabDiv = document.createElement('div'); moveTabDiv.className = 'moveTabPopup';
                const menuBar = document.createElement('div'); menuBar.className = 'menuBar';
                const title = document.createElement('h3'); title.textContent = `タブ移動 - ${parentWindow.name}`;
                const closeBtn = document.createElement('button'); closeBtn.className = 'closeMoveTab'; closeBtn.textContent = '×';
                menuBar.append(title, closeBtn);
                const content = document.createElement('div'); content.className = 'moveTabContent'; content.style.padding = '10px';
                moveTabDiv.append(menuBar, content);
                document.body.appendChild(moveTabDiv);
                state.activePopup = moveTabDiv;
                bringToFrontPopup(moveTabDiv);

                const allItems = GM_getValue('savedItems', []); const autoTabs = new Set(allItems.map(item => item.tab).filter(t => !state.customTabs.has(t))); const allTabs = [...state.customTabs, ...autoTabs];
                allTabs.forEach(tab => {
                    const btn = document.createElement('button'); btn.textContent = tab;
                    events.add(btn, 'click', () => {
                        let allItems = GM_getValue('savedItems', []);
                        checkboxes.forEach(cb => { const timestamp = cb.parentElement.dataset.timestamp; const item = allItems.find(i => i.timestamp === timestamp); if (item) item.tab = tab; });
                        GM_setValue('savedItems', allItems); displaySavedItems(parentWindow); moveTabDiv.remove(); state.activePopup = null;
                    });
                    content.appendChild(btn);
                });
                events.add(closeBtn, 'click', () => { moveTabDiv.remove(); state.activePopup = null; });
                return moveTabDiv;
            };

            const createTabManageWindow = (parentWindow) => {
                // 既存のタブ管理ウィンドウがあれば閉じる
                if (state.activePopup && state.activePopup.className === 'tabManagePopup') {
                    state.activePopup.remove();
                    state.activePopup = null;
                    return;
                }
                if (state.activePopup) { state.activePopup.remove(); state.activePopup = null; }

                const tabManageDiv = document.createElement('div');
                tabManageDiv.className = 'tabManagePopup';
                tabManageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 500px;
                    height: 600px;
                    background: #0a1f2e;
                    border: 2px solid #104437;
                    border-radius: 10px;
                    z-index: 20000;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                    font-family: sans-serif;
                    color: white;
                `;

                const menuBar = document.createElement('div');
                menuBar.className = 'menuBar';
                menuBar.style.cssText = `
                    background: #104437;
                    padding: 10px 15px;
                    border-radius: 8px 8px 0 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    cursor: move;
                    user-select: none;
                `;

                const title = document.createElement('h3');
                title.textContent = `タブ管理 - ${parentWindow.activeTab}`;
                title.style.cssText = `
                    margin: 0;
                    font-size: 16px;
                    font-weight: bold;
                    color: white;
                `;

                const closeBtn = document.createElement('button');
                closeBtn.className = 'closeTabManage';
                closeBtn.textContent = '×';
                closeBtn.style.cssText = `
                    background: #e74c3c;
                            color: white;
                            border: none;
                    border-radius: 50%;
                    width: 25px;
                    height: 25px;
                            cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                menuBar.append(title, closeBtn);

                const content = document.createElement('div');
                content.className = 'tabManageContent';
                content.style.cssText = `
                    padding: 15px;
                    flex: 1;
                    overflow-y: auto;
                    background: #0a1f2e;
                `;

                // タブ追加セクション
                const addSection = document.createElement('div');
                addSection.style.cssText = `
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #1a2f3e;
                    border-radius: 8px;
                    border: 1px solid #104437;
                `;

                const addTitle = document.createElement('h4');
                addTitle.textContent = '📝 新規タブ追加';
                addTitle.style.cssText = `
                    margin: 0 0 15px 0;
                    font-size: 14px;
                    font-weight: bold;
                    color: #16a085;
                `;

                const addForm = document.createElement('div');
                addForm.style.cssText = `
                    display: flex;
                    gap: 10px;
                    align-items: center;
                `;

                        const label = document.createElement('label');
                        label.textContent = 'タブ名: ';
                label.style.cssText = `
                    color: #ccc;
                    font-size: 12px;
                    white-space: nowrap;
                `;

                        const input = document.createElement('input');
                        input.type = 'text';
                        input.id = 'tabNameInput';
                input.placeholder = '新規タブ名を入力';
                input.style.cssText = `
                    flex: 1;
                    padding: 8px 12px;
                    border: 1px solid #104437;
                    border-radius: 5px;
                    background: #0a1f2e;
                    color: white;
                    font-size: 12px;
                `;

                        const addBtn = document.createElement('button');
                        addBtn.id = 'addTabConfirm';
                        addBtn.textContent = '追加';
                addBtn.style.cssText = `
                    background: #16a085;
                    color: white;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: bold;
                    transition: background-color 0.2s;
                `;

                addForm.append(label, input, addBtn);
                addSection.append(addTitle, addForm);

                // タブ設定セクション
                const settingsSection = document.createElement('div');
                settingsSection.style.cssText = `
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #1a2f3e;
                    border-radius: 8px;
                    border: 1px solid #104437;
                `;

                        const settingsTitle = document.createElement('h4');
                settingsTitle.textContent = '⚙️ タブ設定';
                settingsTitle.style.cssText = `
                    margin: 0 0 15px 0;
                    font-size: 14px;
                    font-weight: bold;
                    color: #16a085;
                `;

                        const settingsDiv = document.createElement('div');
                        settingsDiv.id = 'tabSettings';
                settingsDiv.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                `;

                settingsSection.append(settingsTitle, settingsDiv);

                content.append(addSection, settingsSection);

                        const allItems = GM_getValue('savedItems', []);
                        const autoTabs = new Set(allItems.map(item => item.tab).filter(t => !state.customTabs.has(t)));
                        const allTabs = [...state.customTabs, ...autoTabs];

                        allTabs.forEach(tab => {
                    const tabDiv = document.createElement('div');
                    tabDiv.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        padding: 12px;
                        background: #0a1f2e;
                        border: 1px solid #104437;
                        border-radius: 8px;
                        margin-bottom: 8px;
                    `;

                    const tabInfo = document.createElement('div');
                    tabInfo.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        flex: 1;
                    `;

                            const favicon = allItems.find(item => item.tab === tab)?.favicon;
                    const iconDiv = document.createElement('div');
                    iconDiv.style.cssText = `
                        width: 24px;
                        height: 24px;
                        border-radius: 4px;
                        background: ${state.tabColors.get(tab) || '#104437'};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        color: white;
                        flex-shrink: 0;
                    `;

                    if (favicon && !state.customTabs.has(tab) && !state.tabThumbnails.has(tab)) {
                        const img = document.createElement('img');
                        img.src = favicon;
                        img.style.cssText = 'width: 16px; height: 16px; border-radius: 2px;';
                        img.onerror = () => {
                            iconDiv.textContent = tab[0];
                        };
                        iconDiv.appendChild(img);
                    } else {
                        iconDiv.textContent = state.tabThumbnails.get(tab) || tab[0];
                    }

                    const tabName = document.createElement('span');
                    tabName.textContent = tab;
                    tabName.style.cssText = `
                        color: white;
                        font-size: 13px;
                        font-weight: 500;
                    `;

                    tabInfo.append(iconDiv, tabName);

                    const buttonGroup = document.createElement('div');
                    buttonGroup.style.cssText = `
                        display: flex;
                        gap: 5px;
                    `;

                    const colorBtn = document.createElement('button');
                    colorBtn.textContent = '🎨';
                    colorBtn.title = '色を変更';
                    colorBtn.style.cssText = `
                        background: #3498db;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        width: 30px;
                        height: 30px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: background-color 0.2s;
                    `;
                    events.add(colorBtn, 'click', () => setupTabColorMenu(tab, iconDiv, settingsDiv));

                    const thumbnailBtn = document.createElement('button');
                    thumbnailBtn.textContent = '🖼️';
                    thumbnailBtn.title = 'サムネイルを変更';
                    thumbnailBtn.style.cssText = `
                        background: #9b59b6;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        width: 30px;
                        height: 30px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: background-color 0.2s;
                    `;
                    events.add(thumbnailBtn, 'click', () => setupTabThumbnailMenu(tab, iconDiv, favicon, settingsDiv));

                    const domainNameBtn = document.createElement('button');
                    domainNameBtn.textContent = '🌐';
                    domainNameBtn.title = 'ドメイン名表示設定';
                    domainNameBtn.style.cssText = `
                        background: ${state.tabDomainNames.get(tab) ? '#27ae60' : '#95a5a6'};
                        color: white;
                        border: none;
                        border-radius: 4px;
                        width: 30px;
                        height: 30px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: background-color 0.2s;
                    `;
                    events.add(domainNameBtn, 'click', () => setupTabDomainNameMenu(tab, domainNameBtn, settingsDiv));

                            const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '🗑️';
                    deleteBtn.title = 'タブを削除';
                    deleteBtn.style.cssText = `
                        background: #e74c3c;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        width: 30px;
                        height: 30px;
                        cursor: pointer;
                        font-size: 12px;
                        transition: background-color 0.2s;
                    `;
                            events.add(deleteBtn, 'click', () => {
                                if (confirm(`${tab}タブを削除しますか？（関連アイテムも削除されます）`)) {
                                    if (state.customTabs.has(tab)) {
                                        state.customTabs.delete(tab);
                                        state.updateCustomTabs([...state.customTabs]);
                                    }
                                    const updatedItems = allItems.filter(item => item.tab !== tab);
                                    GM_setValue('savedItems', updatedItems);
                                    state.tabColors.delete(tab);
                                    state.tabThumbnails.delete(tab);
                                    state.tabDomainNames.delete(tab);
                                    if (parentWindow.activeTab === tab) parentWindow.activeTab = state.customTabs.values().next().value || '';
                                    updateTabs(parentWindow);
                            tabDiv.remove();
                        }
                    });

                    buttonGroup.append(colorBtn, thumbnailBtn, domainNameBtn, deleteBtn);
                    tabDiv.append(tabInfo, buttonGroup);
                    settingsDiv.appendChild(tabDiv);
                        });

                        const handleAddTab = () => {
                            const tabName = input.value;
                            if (tabName && !state.customTabs.has(tabName)) {
                                state.customTabs.add(tabName);
                                state.updateCustomTabs([...state.customTabs]);
                                updateTabs(parentWindow);
                        cleanupTabManage(tabManageDiv);
                            }
                        };

                        events.add(addBtn, 'click', handleAddTab);
                events.add(closeBtn, 'click', () => cleanupTabManage(tabManageDiv));

                // ドラッグ機能を追加
                let isDragging = false;
                let offsetX, offsetY;

                const handleMouseMove = (e) => {
                    if (isDragging) {
                        let leftPx = e.clientX - offsetX;
                        let topPx = e.clientY - offsetY;
                        let widthPx = tabManageDiv.offsetWidth;
                        let heightPx = tabManageDiv.offsetHeight;

                        leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - widthPx));
                        topPx = Math.max(0, Math.min(topPx, window.innerHeight - heightPx));

                        requestAnimationFrame(() => {
                            tabManageDiv.style.left = `${leftPx}px`;
                            tabManageDiv.style.top = `${topPx}px`;
                            tabManageDiv.style.transform = 'none';
                        });
                    }
                };

                const handleMouseUp = () => {
                    if (isDragging) {
                        isDragging = false;
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    }
                };

                events.add(menuBar, 'mousedown', (e) => {
                    if (e.target === closeBtn) return; // 閉じるボタンではドラッグしない
                    isDragging = true;
                    // 現在の位置を取得（transformを考慮）
                    const rect = tabManageDiv.getBoundingClientRect();
                    offsetX = e.clientX - rect.left;
                    offsetY = e.clientY - rect.top;
                    e.preventDefault();
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });

                // ボタンのホバー効果を追加
                events.add(addBtn, 'mouseenter', () => {
                    addBtn.style.background = '#1abc9c';
                });
                events.add(addBtn, 'mouseleave', () => {
                    addBtn.style.background = '#16a085';
                });

                tabManageDiv.append(menuBar, content);
                document.body.appendChild(tabManageDiv);
                state.activePopup = tabManageDiv;
                bringToFrontPopup(tabManageDiv);

                return tabManageDiv;
            };

            const setupTabColorMenu = (tab, div, settingsDiv) => {
                const colorMenu = document.createElement('div'); colorMenu.className = 'tabMenu';
                colorMenu.style.position = 'absolute'; colorMenu.style.left = `${div.offsetLeft + div.offsetWidth}px`; colorMenu.style.top = `${div.offsetTop}px`;
                Window.colorPresets.forEach((color, name) => {
                    const btn = document.createElement('button'); btn.textContent = name; btn.style.backgroundColor = color;
                    events.add(btn, 'click', () => { state.setTabColor(tab, color); div.style.backgroundColor = color; updateTabs(state.window); colorMenu.remove(); });
                    colorMenu.appendChild(btn);
                });
                const resetColorBtn = document.createElement('button'); resetColorBtn.textContent = 'デフォルト色に戻す';
                events.add(resetColorBtn, 'click', () => { state.tabColors.delete(tab); GM_setValue('tabColors', Object.fromEntries(state.tabColors)); div.style.backgroundColor = '#104437'; updateTabs(state.window); colorMenu.remove(); });
                colorMenu.appendChild(resetColorBtn);
                settingsDiv.appendChild(colorMenu);
            };

            const setupTabDomainNameMenu = (tab, btn, settingsDiv) => {
                const domainMenu = document.createElement('div');
                domainMenu.className = 'tabMenu';
                domainMenu.style.cssText = `
                    position: absolute;
                    left: ${btn.offsetLeft + btn.offsetWidth}px;
                    top: ${btn.offsetTop}px;
                    background: #1a2f3e;
                    border: 1px solid #104437;
                    border-radius: 8px;
                    padding: 10px;
                    z-index: 20001;
                    min-width: 200px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;

                const title = document.createElement('div');
                title.textContent = 'ドメイン名表示設定';
                title.style.cssText = `
                    font-weight: bold;
                    color: #16a085;
                    margin-bottom: 10px;
                    font-size: 12px;
                `;
                domainMenu.appendChild(title);

                const currentSetting = state.tabDomainNames.get(tab);

                const enableBtn = document.createElement('button');
                enableBtn.textContent = '✅ ドメイン名を表示';
                enableBtn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 8px 12px;
                    margin-bottom: 5px;
                    background: ${currentSetting ? '#27ae60' : '#34495e'};
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 11px;
                    text-align: left;
                `;
                events.add(enableBtn, 'click', () => {
                    state.setTabDomainName(tab, true);
                    btn.style.background = '#27ae60';
                    updateTabs(state.window);
                    domainMenu.remove();
                });

                const disableBtn = document.createElement('button');
                disableBtn.textContent = '❌ ファビコンのみ表示';
                disableBtn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 8px 12px;
                    background: ${!currentSetting ? '#e74c3c' : '#34495e'};
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 11px;
                    text-align: left;
                `;
                events.add(disableBtn, 'click', () => {
                    state.setTabDomainName(tab, false);
                    btn.style.background = '#95a5a6';
                    updateTabs(state.window);
                    domainMenu.remove();
                });

                const resetBtn = document.createElement('button');
                resetBtn.textContent = '🔄 デフォルトに戻す';
                resetBtn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 8px 12px;
                    margin-top: 5px;
                    background: #f39c12;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 11px;
                    text-align: left;
                `;
                events.add(resetBtn, 'click', () => {
                    state.tabDomainNames.delete(tab);
                    GM_setValue('tabDomainNames', Object.fromEntries(state.tabDomainNames));
                    btn.style.background = '#95a5a6';
                    updateTabs(state.window);
                    domainMenu.remove();
                });

                domainMenu.append(title, enableBtn, disableBtn, resetBtn);
                settingsDiv.appendChild(domainMenu);

                // 外部クリックでメニューを閉じる
                setTimeout(() => {
                    const closeMenu = (e) => {
                        if (!domainMenu.contains(e.target) && !btn.contains(e.target)) {
                            domainMenu.remove();
                            document.removeEventListener('click', closeMenu);
                        }
                    };
                    document.addEventListener('click', closeMenu);
                }, 0);
            };

            const setupTabThumbnailMenu = (tab, div, favicon, settingsDiv) => {
                const thumbMenu = document.createElement('div'); thumbMenu.className = 'tabMenu';
                thumbMenu.style.position = 'absolute'; thumbMenu.style.left = `${div.offsetLeft + div.offsetWidth}px`; thumbMenu.style.top = `${div.offsetTop}px`;
                Window.thumbnailPresets.forEach(emoji => {
                    const btn = document.createElement('button'); btn.textContent = emoji;
                    events.add(btn, 'click', () => { state.setTabThumbnail(tab, emoji); div.innerHTML = `<span>${emoji}</span>`; updateTabs(state.window); thumbMenu.remove(); });
                    thumbMenu.appendChild(btn);
                });
                const resetBtn = document.createElement('button'); resetBtn.textContent = '元のファビコン';
                events.add(resetBtn, 'click', () => { state.tabThumbnails.delete(tab); GM_setValue('tabThumbnails', Object.fromEntries(state.tabThumbnails)); div.innerHTML = favicon && !state.customTabs.has(tab) ? `<img src="${favicon}" width="16" height="16">` : `<span>${tab[0]}</span>`; updateTabs(state.window); thumbMenu.remove(); });
                thumbMenu.appendChild(resetBtn);
                settingsDiv.appendChild(thumbMenu);
            };

            const cleanupTabManage = (tabManageDiv) => { tabManageDiv.querySelectorAll('button').forEach(btn => btn.replaceWith(btn.cloneNode(true))); tabManageDiv.remove(); state.activePopup = null; };

            const bringToFront = (windowObj) => { state.zIndexCounter++; if (state.activePopup && state.zIndexCounter >= parseInt(state.activePopup.style.zIndex)) state.zIndexCounter = parseInt(state.activePopup.style.zIndex) + 1; windowObj.el.style.zIndex = state.zIndexCounter; };

            const bringToFrontPopup = (popup) => { state.zIndexCounter = Math.max(state.zIndexCounter + 1, 20000); popup.style.zIndex = state.zIndexCounter; };

            const addCloseOnClickOutside = (menu, menuBar) => {
                const closeMenu = (e) => { logMessage(`外部クリック検知: target=${e.target.tagName}, menuBar=${menuBar.contains(e.target)}, menu=${menu.contains(e.target)}`); setTimeout(() => { if (!menuBar.contains(e.target) && !menu.contains(e.target)) { logMessage('サブメニューを閉じます'); closeActiveMenu(); state.isHoverEnabled = false; document.removeEventListener('click', closeMenu); } }, 0); };
                document.addEventListener('click', closeMenu); menu.addEventListener('remove', () => { document.removeEventListener('click', closeMenu); logMessage('サブメニュー削除に伴いリスナー解除'); }, { once: true });
            };

            const closeActiveMenu = () => { if (state.activeMenu) { state.activeMenu.remove(); state.activeMenu = null; } };

            const createElementEditWindow = (windowObj) => {
                // 既存の要素編集ウィンドウがあれば閉じる
                if (state.activePopup && state.activePopup.className === 'elementEditPopup') {
                    state.activePopup.remove();
                    state.activePopup = null;
                    return;
                }
                if (state.activePopup) { state.activePopup.remove(); state.activePopup = null; }

                const elementEditDiv = document.createElement('div'); elementEditDiv.className = 'elementEditPopup';
                const menuBar = document.createElement('div'); menuBar.className = 'menuBar';
                const title = document.createElement('h3'); title.textContent = `要素編集 - ${windowObj.activeTab}`;

                const closeBtn = document.createElement('button'); closeBtn.className = 'closeElementEdit'; closeBtn.textContent = '×';
                menuBar.append(title, closeBtn);

                const content = document.createElement('div'); content.className = 'elementEditContent'; content.style.padding = '15px';

                const domain = windowObj.activeTab;
                const defaultSelectors = {
                    tagSelector: 'div.q-chip',
                    tagContentSelector: '.q-chip__content',
                    dateSelector: 'div.absolute-bottom-right'
                };

                const currentSelectors = state.elementSelectors.get(domain) || defaultSelectors;

                // セレクター編集セクション
                const editSection = document.createElement('div'); editSection.style.marginBottom = '20px';
                const editTitle = document.createElement('h4'); editTitle.textContent = '🔧 セレクター編集'; editTitle.style.marginBottom = '10px';

                // タグ要素セレクター編集
                const tagEditSection = document.createElement('div'); tagEditSection.style.marginBottom = '15px';
                const tagEditTitle = document.createElement('h5'); tagEditTitle.textContent = '📌 タグ要素セレクター'; tagEditTitle.style.marginBottom = '8px';

                const tagSelectorDiv = document.createElement('div'); tagSelectorDiv.style.marginBottom = '10px';
                const tagSelectorLabel = document.createElement('label'); tagSelectorLabel.textContent = 'タグ要素セレクター:'; tagSelectorLabel.style.display = 'block'; tagSelectorLabel.style.marginBottom = '5px';
                const tagSelectorInput = document.createElement('input'); tagSelectorInput.type = 'text'; tagSelectorInput.value = currentSelectors.tagSelector; tagSelectorInput.style.width = '100%'; tagSelectorInput.style.padding = '5px'; tagSelectorInput.style.fontFamily = 'monospace';

                const tagContentSelectorDiv = document.createElement('div'); tagContentSelectorDiv.style.marginBottom = '10px';
                const tagContentSelectorLabel = document.createElement('label'); tagContentSelectorLabel.textContent = 'タグ内容セレクター（オプション）:'; tagContentSelectorLabel.style.display = 'block'; tagContentSelectorLabel.style.marginBottom = '5px';
                const tagContentSelectorInput = document.createElement('input'); tagContentSelectorInput.type = 'text'; tagContentSelectorInput.value = currentSelectors.tagContentSelector || ''; tagContentSelectorInput.style.width = '100%'; tagContentSelectorInput.style.padding = '5px'; tagContentSelectorInput.style.fontFamily = 'monospace';

                tagSelectorDiv.append(tagSelectorLabel, tagSelectorInput);
                tagContentSelectorDiv.append(tagContentSelectorLabel, tagContentSelectorInput);
                tagEditSection.append(tagEditTitle, tagSelectorDiv, tagContentSelectorDiv);

                // 日付要素セレクター編集
                const dateEditSection = document.createElement('div'); dateEditSection.style.marginBottom = '15px';
                const dateEditTitle = document.createElement('h5'); dateEditTitle.textContent = '📅 日付要素セレクター'; dateEditTitle.style.marginBottom = '8px';

                const dateSelectorDiv = document.createElement('div'); dateSelectorDiv.style.marginBottom = '10px';
                const dateSelectorLabel = document.createElement('label'); dateSelectorLabel.textContent = '日付要素セレクター:'; dateSelectorLabel.style.display = 'block'; dateSelectorLabel.style.marginBottom = '5px';
                const dateSelectorInput = document.createElement('input'); dateSelectorInput.type = 'text'; dateSelectorInput.value = currentSelectors.dateSelector; dateSelectorInput.style.width = '100%'; dateSelectorInput.style.padding = '5px'; dateSelectorInput.style.fontFamily = 'monospace';

                dateSelectorDiv.append(dateSelectorLabel, dateSelectorInput);
                dateEditSection.append(dateEditTitle, dateSelectorDiv);

                // 保存・リセットボタン
                const buttonSection = document.createElement('div'); buttonSection.style.display = 'flex'; buttonSection.style.gap = '10px'; buttonSection.style.marginBottom = '20px';

                const saveBtn = document.createElement('button'); saveBtn.textContent = '💾 保存'; saveBtn.style.padding = '8px 15px'; saveBtn.style.background = '#27ae60'; saveBtn.style.color = 'white'; saveBtn.style.border = 'none'; saveBtn.style.borderRadius = '5px'; saveBtn.style.cursor = 'pointer';
                const resetBtn = document.createElement('button'); resetBtn.textContent = '🔄 デフォルトに戻す'; resetBtn.style.padding = '8px 15px'; resetBtn.style.background = '#e67e22'; resetBtn.style.color = 'white'; resetBtn.style.border = 'none'; resetBtn.style.borderRadius = '5px'; resetBtn.style.cursor = 'pointer';
                const testBtn = document.createElement('button'); testBtn.textContent = '🧪 テスト実行'; testBtn.style.padding = '8px 15px'; testBtn.style.background = '#3498db'; testBtn.style.color = 'white'; testBtn.style.border = 'none'; testBtn.style.borderRadius = '5px'; testBtn.style.cursor = 'pointer';

                buttonSection.append(saveBtn, resetBtn, testBtn);

                // 現在のページでの要素検証
                const verificationSection = document.createElement('div'); verificationSection.style.marginBottom = '20px';
                const verificationTitle = document.createElement('h4'); verificationTitle.textContent = '🔍 現在のページでの要素検証'; verificationTitle.style.marginBottom = '10px';

                const verificationInfo = document.createElement('div'); verificationInfo.style.cssText = 'background: #0a1f2e; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 11px; line-height: 1.4;';

                // 実際の要素を検証
                const tagElements = document.querySelectorAll(currentSelectors.tagSelector);
                const dateElement = document.querySelector(currentSelectors.dateSelector);

                let verificationDetails = '';

                // タグ要素の検証
                verificationDetails += `タグ要素 (${currentSelectors.tagSelector}):\n`;
                verificationDetails += `  見つかった要素数: ${tagElements.length}個\n`;

                if (tagElements.length > 0) {
                    verificationDetails += `  最初の3つの要素:\n`;
                    Array.from(tagElements).slice(0, 3).forEach((el, index) => {
                        let content = el;
                        if (currentSelectors.tagContentSelector) {
                            content = el.querySelector(currentSelectors.tagContentSelector);
                        }
                        const text = content ? content.textContent.trim() : '内容なし';
                        verificationDetails += `    ${index + 1}. "${text}"\n`;
                    });
                }

                verificationDetails += `\n日付要素 (${currentSelectors.dateSelector}):\n`;
                if (dateElement) {
                    verificationDetails += `  見つかった: はい\n`;
                    verificationDetails += `  内容: "${dateElement.textContent.trim()}"\n`;
                } else {
                    verificationDetails += `  見つかった: いいえ\n`;
                }

                verificationInfo.textContent = verificationDetails;
                verificationSection.append(verificationTitle, verificationInfo);

                // 説明文
                const descriptionSection = document.createElement('div'); descriptionSection.style.marginBottom = '20px';
                const descriptionTitle = document.createElement('h4'); descriptionTitle.textContent = 'ℹ️ 説明'; descriptionTitle.style.marginBottom = '10px';
                const descriptionText = document.createElement('div'); descriptionText.style.cssText = 'background: #0a1f2e; padding: 10px; border-radius: 5px; font-size: 12px; line-height: 1.4; color: #95a5a6;';

                descriptionText.innerHTML = `
    現在のセレクター設定を編集できます。<br>
    • タグ要素セレクター: タグを含む要素を指定<br>
    • タグ内容セレクター: タグ要素内のテキストを含む要素を指定（オプション）<br>
    • 日付要素セレクター: 日付を含む要素を指定<br><br>
    例: YouTubeの場合<br>
    • タグ要素: <code>a.bold.yt-formatted-string.style-scope.yt-simple-endpoint</code><br>
    • 日付要素: <code>span.bold.yt-formatted-string.style-scope</code>
                `;

                descriptionSection.append(descriptionTitle, descriptionText);

                // イベントリスナー
                events.add(saveBtn, 'click', () => {
                    const newSelectors = {
                        tagSelector: tagSelectorInput.value.trim(),
                        tagContentSelector: tagContentSelectorInput.value.trim() || null,
                        dateSelector: dateSelectorInput.value.trim()
                    };

                    if (newSelectors.tagSelector && newSelectors.dateSelector) {
                        state.setElementSelectors(domain, newSelectors);
                        logMessage(`セレクター設定を保存しました: ${domain}`);
                        alert('セレクター設定を保存しました！');
                    } else {
                        alert('タグ要素セレクターと日付要素セレクターは必須です。');
                    }
                });

                events.add(resetBtn, 'click', () => {
                    tagSelectorInput.value = defaultSelectors.tagSelector;
                    tagContentSelectorInput.value = defaultSelectors.tagContentSelector;
                    dateSelectorInput.value = defaultSelectors.dateSelector;
                    state.elementSelectors.delete(domain);
                    state.setElementSelectors(domain, null);
                    logMessage(`セレクター設定をデフォルトに戻しました: ${domain}`);
                    alert('セレクター設定をデフォルトに戻しました！');
                });

                events.add(testBtn, 'click', () => {
                    const testSelectors = {
                        tagSelector: tagSelectorInput.value.trim(),
                        tagContentSelector: tagContentSelectorInput.value.trim() || null,
                        dateSelector: dateSelectorInput.value.trim()
                    };

                    // テスト実行
                    const testTags = new Set();
                    const testTagElements = document.querySelectorAll(testSelectors.tagSelector);
                    testTagElements.forEach(el => {
                        let content = el;
                        if (testSelectors.tagContentSelector) {
                            content = el.querySelector(testSelectors.tagContentSelector);
                        }
                        if (content && content.textContent.trim()) {
                            const tagText = content.textContent.trim();
                            if (tagText.length > 0 && tagText.length < 20) testTags.add(tagText);
                        }
                    });

                    const testDateElement = document.querySelector(testSelectors.dateSelector);
                    const testDate = testDateElement ? testDateElement.textContent.trim() : null;

                    const testResult = `テスト結果:\nタグ要素: ${testTagElements.length}個見つかりました\nタグ: ${Array.from(testTags).join(', ') || 'なし'}\n日付: ${testDate || 'なし'}`;
                    alert(testResult);
                });

                content.append(editSection, tagEditSection, dateEditSection, buttonSection, verificationSection, descriptionSection);
                elementEditDiv.append(menuBar, content);
                document.body.appendChild(elementEditDiv);
                state.activePopup = elementEditDiv;
                bringToFrontPopup(elementEditDiv);

                events.add(closeBtn, 'click', () => { elementEditDiv.remove(); state.activePopup = null; });

                return elementEditDiv;
            };

            const resizeSelectedImages = (windowObj, checkboxes) => {
                const allItems = GM_getValue('savedItems', []);
                let processedCount = 0;
                let totalSaved = 0;

                checkboxes.forEach(cb => {
                    const timestamp = cb.parentElement.dataset.timestamp;
                    const item = allItems.find(i => i.timestamp === timestamp);
                    if (item && item.image) {
                        const originalSize = new Blob([item.image]).size;

                        // 画像をリサイズ
                        const img = new Image();
                        img.onload = () => {
                            try {
                                                        const canvas = document.createElement('canvas');
                            const maxSize = 150;

                                // アスペクト比を保ちながら150x150px以下にリサイズ
                                let targetWidth = img.width;
                                let targetHeight = img.height;

                                if (targetWidth > maxSize || targetHeight > maxSize) {
                                    const ratio = Math.min(maxSize / targetWidth, maxSize / targetHeight);
                                    targetWidth = Math.floor(targetWidth * ratio);
                                    targetHeight = Math.floor(targetHeight * ratio);
                                }

                                canvas.width = targetWidth;
                                canvas.height = targetHeight;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

                                                        // JPEG品質0.3で保存（より高圧縮）
                            const resizedImage = canvas.toDataURL('image/jpeg', 0.3);
                                item.image = resizedImage;

                                const newSize = new Blob([resizedImage]).size;
                                totalSaved += (originalSize - newSize);
                                processedCount++;

                                logMessage(`画像リサイズ完了: ${targetWidth}x${targetHeight} (${(newSize/1024).toFixed(1)}KB)`);

                                // 最後の画像が処理されたら保存
                                if (processedCount === checkboxes.length) {
                                    GM_setValue('savedItems', allItems);
                                    displaySavedItems(windowObj);
                                    const savedKB = (totalSaved / 1024).toFixed(1);
                                    alert(`リサイズ完了！\n${processedCount}件の画像を処理しました。\n合計${savedKB}KB削減しました。`);
                                }
                            } catch (e) {
                                logMessage(`画像リサイズ失敗: ${e.message}`);
                                processedCount++;
                            }
                        };
                        img.onerror = () => {
                            logMessage(`画像読み込み失敗: ${timestamp}`);
                            processedCount++;
                        };
                        img.src = item.image;
                    } else {
                        processedCount++;
                    }
                });
            };

            const createTagEditWindow = (windowObj) => {
                // 既存のタグ編集ウィンドウがあれば閉じる
                if (state.activePopup && state.activePopup.className === 'tagEditPopup') {
                    state.activePopup.remove();
                    state.activePopup = null;
                    return;
                }
                if (state.activePopup) { state.activePopup.remove(); state.activePopup = null; }

                const tagEditDiv = document.createElement('div');
                tagEditDiv.className = 'tagEditPopup';
                tagEditDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 600px;
                    height: 700px;
                    background: #0a1f2e;
                    border: 2px solid #104437;
                    border-radius: 10px;
                    z-index: 20000;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                    font-family: sans-serif;
                    color: white;
                `;

                const menuBar = document.createElement('div');
                menuBar.className = 'menuBar';
                menuBar.style.cssText = `
                    background: #104437;
                    padding: 10px 15px;
                    border-radius: 8px 8px 0 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    cursor: move;
                    user-select: none;
                `;

                const title = document.createElement('h3');
                title.textContent = `タグ編集 - ${windowObj.activeTab}`;
                title.style.cssText = `
                    margin: 0;
                    font-size: 16px;
                    font-weight: bold;
                    color: white;
                `;

                const closeBtn = document.createElement('button');
                closeBtn.className = 'closeTagEdit';
                closeBtn.textContent = '×';
                closeBtn.style.cssText = `
                    background: #e74c3c;
                    color: white;
                    border: none;
                    border-radius: 50%;
                    width: 25px;
                    height: 25px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                menuBar.append(title, closeBtn);

                const content = document.createElement('div');
                content.className = 'tagEditContent';
                content.style.cssText = `
                    padding: 15px;
                    flex: 1;
                    overflow-y: auto;
                    background: #0a1f2e;
                `;

                // タグ追加セクション
                const addSection = document.createElement('div');
                addSection.style.cssText = `
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #1a2f3e;
                    border-radius: 8px;
                    border: 1px solid #104437;
                `;

                const addTitle = document.createElement('h4');
                addTitle.textContent = '📝 タグを追加';
                addTitle.style.cssText = `
                    margin: 0 0 15px 0;
                    font-size: 14px;
                    font-weight: bold;
                    color: #16a085;
                `;

                const addForm = document.createElement('div');
                addForm.style.cssText = `
                    display: flex;
                    gap: 10px;
                    align-items: center;
                `;

                const tagInput = document.createElement('input');
                tagInput.type = 'text';
                tagInput.placeholder = '新しいタグ名を入力';
                tagInput.style.cssText = `
                    flex: 1;
                    padding: 8px 12px;
                    border: 1px solid #104437;
                    border-radius: 5px;
                    background: #0a1f2e;
                    color: white;
                    font-size: 12px;
                `;

                const addBtn = document.createElement('button');
                addBtn.textContent = '追加';
                addBtn.style.cssText = `
                    background: #16a085;
                    color: white;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: bold;
                    transition: background-color 0.2s;
                `;

                addForm.append(tagInput, addBtn);
                addSection.append(addTitle, addForm);

                // 除外タグセクション
                const excludeSection = document.createElement('div');
                excludeSection.style.cssText = `
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #1a2f3e;
                    border-radius: 8px;
                    border: 1px solid #104437;
                `;

                const excludeTitle = document.createElement('h4');
                excludeTitle.textContent = '🚫 除外タグ設定';
                excludeTitle.style.cssText = `
                    margin: 0 0 15px 0;
                    font-size: 14px;
                    font-weight: bold;
                    color: #16a085;
                `;

                // 除外タイプ選択
                const excludeTypeDiv = document.createElement('div');
                excludeTypeDiv.style.cssText = `
                    margin-bottom: 15px;
                    display: flex;
                    align-items: center;
                    gap: 15px;
                `;

                const exactRadio = document.createElement('input');
                exactRadio.type = 'radio';
                exactRadio.name = 'excludeType';
                exactRadio.value = 'exact';
                exactRadio.checked = true;
                exactRadio.style.cssText = `
                    margin: 0;
                    cursor: pointer;
                `;

                const exactLabel = document.createElement('label');
                exactLabel.textContent = '完全一致';
                exactLabel.style.cssText = `
                    color: #ccc;
                    font-size: 12px;
                    cursor: pointer;
                    margin: 0;
                `;

                const regexRadio = document.createElement('input');
                regexRadio.type = 'radio';
                regexRadio.name = 'excludeType';
                regexRadio.value = 'regex';
                regexRadio.style.cssText = `
                    margin: 0;
                    cursor: pointer;
                `;

                const regexLabel = document.createElement('label');
                regexLabel.textContent = '正規表現';
                regexLabel.style.cssText = `
                    color: #ccc;
                    font-size: 12px;
                    cursor: pointer;
                    margin: 0;
                `;

                excludeTypeDiv.append(exactRadio, exactLabel, regexRadio, regexLabel);

                const excludeForm = document.createElement('div');
                excludeForm.style.cssText = `
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    margin-bottom: 10px;
                `;

                const excludeInput = document.createElement('input');
                excludeInput.type = 'text';
                excludeInput.placeholder = '除外するタグ名（例：ABC）または正規表現（例：ABC\\d+）';
                excludeInput.style.cssText = `
                    flex: 1;
                    padding: 8px 12px;
                    border: 1px solid #104437;
                    border-radius: 5px;
                    background: #0a1f2e;
                    color: white;
                    font-size: 12px;
                `;

                const addExcludeBtn = document.createElement('button');
                addExcludeBtn.textContent = '除外に追加';
                addExcludeBtn.style.cssText = `
                    background: #e67e22;
                    color: white;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: bold;
                    transition: background-color 0.2s;
                `;

                excludeForm.append(excludeInput, addExcludeBtn);

                // 除外タグ管理ボタン
                const manageExcludeBtn = document.createElement('button');
                manageExcludeBtn.textContent = '除外タグ管理';
                manageExcludeBtn.style.cssText = `
                    background: #e74c3c;
                    color: white;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 5px;
                    font-size: 12px;
                    cursor: pointer;
                    width: 100%;
                    font-weight: bold;
                    transition: background-color 0.2s;
                `;

                events.add(manageExcludeBtn, 'click', () => {
                    createExcludeManageWindow(windowObj);
                });

                excludeSection.append(excludeTitle, excludeTypeDiv, excludeForm, manageExcludeBtn);

                // 除外タグ表示は削除（除外タグ管理ウィンドウでのみ確認可能）

                // タググループ管理セクション
                const groupSection = document.createElement('div');
                groupSection.style.cssText = `
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #1a2f3e;
                    border-radius: 8px;
                    border: 1px solid #104437;
                `;

                const groupTitle = document.createElement('h4');
                groupTitle.textContent = '📁 タググループ管理';
                groupTitle.style.cssText = `
                    margin: 0 0 15px 0;
                    font-size: 14px;
                    font-weight: bold;
                    color: #16a085;
                `;

                // グループ作成フォーム
                const groupForm = document.createElement('div');
                groupForm.style.cssText = `
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    margin-bottom: 15px;
                `;

                const groupInput = document.createElement('input');
                groupInput.type = 'text';
                groupInput.placeholder = '新しいグループ名を入力';
                groupInput.style.cssText = `
                    flex: 1;
                    padding: 8px 12px;
                    border: 1px solid #104437;
                    border-radius: 5px;
                    background: #0a1f2e;
                    color: white;
                    font-size: 12px;
                `;

                const createGroupBtn = document.createElement('button');
                createGroupBtn.textContent = 'グループ作成';
                createGroupBtn.style.cssText = `
                    background: #9b59b6;
                    color: white;
                    border: none;
                    padding: 8px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: bold;
                    transition: background-color 0.2s;
                `;

                groupForm.append(groupInput, createGroupBtn);

                // 選択されたタグ表示エリア
                const selectedTagsArea = document.createElement('div');
                selectedTagsArea.className = 'selectedTagsArea';
                selectedTagsArea.style.cssText = `
                    background: #0a1f2e;
                    padding: 15px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    min-height: 40px;
                    border: 1px solid #104437;
                `;

                const selectedTagsTitle = document.createElement('div');
                selectedTagsTitle.textContent = '選択されたタグ:';
                selectedTagsTitle.style.cssText = `
                    margin-bottom: 10px;
                    font-size: 12px;
                    color: #16a085;
                    font-weight: bold;
                `;

                selectedTagsArea.appendChild(selectedTagsTitle);

                // 既存グループ表示エリア
                const groupList = document.createElement('div');
                groupList.className = 'groupList';
                groupList.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                `;

                groupSection.append(groupTitle, groupForm, selectedTagsArea, groupList);

                // 既存タグセクション
                const existingSection = document.createElement('div');
                existingSection.style.cssText = `
                    margin-bottom: 20px;
                    padding: 15px;
                    background: #1a2f3e;
                    border-radius: 8px;
                    border: 1px solid #104437;
                `;

                const existingTitle = document.createElement('h4');
                existingTitle.textContent = '🏷️ 既存のタグ';
                existingTitle.style.cssText = `
                    margin: 0 0 15px 0;
                    font-size: 14px;
                    font-weight: bold;
                    color: #16a085;
                `;

                const tagList = document.createElement('div');
                tagList.className = 'tagList';
                tagList.style.cssText = `
                    display: flex;
                    flex-wrap: wrap;
                    gap: 10px;
                `;

                existingSection.append(existingTitle, tagList);
                content.append(addSection, excludeSection, groupSection, existingSection);

                // ドラッグ機能を追加
                let isDragging = false;
                let offsetX, offsetY;

                const handleMouseMove = (e) => {
                    if (isDragging) {
                        let leftPx = e.clientX - offsetX;
                        let topPx = e.clientY - offsetY;
                        let widthPx = tagEditDiv.offsetWidth;
                        let heightPx = tagEditDiv.offsetHeight;

                        leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - widthPx));
                        topPx = Math.max(0, Math.min(topPx, window.innerHeight - heightPx));

                        requestAnimationFrame(() => {
                            tagEditDiv.style.left = `${leftPx}px`;
                            tagEditDiv.style.top = `${topPx}px`;
                            tagEditDiv.style.transform = 'none';
                        });
                    }
                };

                const handleMouseUp = () => {
                    if (isDragging) {
                        isDragging = false;
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    }
                };

                events.add(menuBar, 'mousedown', (e) => {
                    if (e.target === closeBtn) return; // 閉じるボタンではドラッグしない
                    isDragging = true;
                    // 現在の位置を取得（transformを考慮）
                    const rect = tagEditDiv.getBoundingClientRect();
                    offsetX = e.clientX - rect.left;
                    offsetY = e.clientY - rect.top;
                    e.preventDefault();
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });

                // ボタンのホバー効果を追加
                events.add(addBtn, 'mouseenter', () => {
                    addBtn.style.background = '#1abc9c';
                });
                events.add(addBtn, 'mouseleave', () => {
                    addBtn.style.background = '#16a085';
                });

                events.add(addExcludeBtn, 'mouseenter', () => {
                    addExcludeBtn.style.background = '#d35400';
                });
                events.add(addExcludeBtn, 'mouseleave', () => {
                    addExcludeBtn.style.background = '#e67e22';
                });

                events.add(manageExcludeBtn, 'mouseenter', () => {
                    manageExcludeBtn.style.background = '#c0392b';
                });
                events.add(manageExcludeBtn, 'mouseleave', () => {
                    manageExcludeBtn.style.background = '#e74c3c';
                });

                events.add(createGroupBtn, 'mouseenter', () => {
                    createGroupBtn.style.background = '#8e44ad';
                });
                events.add(createGroupBtn, 'mouseleave', () => {
                    createGroupBtn.style.background = '#9b59b6';
                });

                tagEditDiv.append(menuBar, content);
                document.body.appendChild(tagEditDiv);
                state.activePopup = tagEditDiv;
                bringToFrontPopup(tagEditDiv);

                // 既存タグを表示
                const updateTagList = () => {
                    tagList.innerHTML = '';
                    const allItems = GM_getValue('savedItems', []);
                    const currentTabItems = allItems.filter(item => item.tab === windowObj.activeTab);
                    const allTags = new Set();

                    currentTabItems.forEach(item => {
                        if (item.tags && Array.isArray(item.tags)) {
                            item.tags.forEach(tag => allTags.add(tag));
                        }
                    });

                    allTags.forEach(tag => {
                        const tagDiv = document.createElement('div');
                        tagDiv.className = 'tagItem';
                        const isSelected = selectedTags.has(tag);
                        tagDiv.style.cssText = `background: ${isSelected ? '#16a085' : '#104437'}; padding: 5px 10px; border-radius: 15px; display: flex; align-items: center; gap: 8px; color: white; font-size: 12px; cursor: pointer; transition: all 0.2s ease;`;

                        const tagText = document.createElement('span'); tagText.textContent = tag;
                        const deleteBtn = document.createElement('button');
                        deleteBtn.textContent = '×'; deleteBtn.style.cssText = 'background: #e74c3c; border: none; color: white; border-radius: 50%; width: 18px; height: 18px; cursor: pointer; font-size: 10px;';

                        tagDiv.append(tagText, deleteBtn);
                        tagList.appendChild(tagDiv);

                        // タグ選択イベント
                        events.add(tagDiv, 'click', (e) => {
                            if (e.target === deleteBtn) return; // 削除ボタンの場合は選択しない

                            if (selectedTags.has(tag)) {
                                selectedTags.delete(tag);
                                tagDiv.style.background = '#104437';
                            } else {
                                selectedTags.add(tag);
                                tagDiv.style.background = '#16a085';
                            }
                            updateSelectedTagsDisplay();

                            // アニメーション
                            tagDiv.animate([
                                { transform: 'scale(1)' },
                                { transform: 'scale(1.05)' },
                                { transform: 'scale(1)' }
                            ], {
                                duration: 200,
                                easing: 'ease-in-out'
                            });
                        });

                        // タグ削除イベント
                        events.add(deleteBtn, 'click', (e) => {
                            e.stopPropagation(); // 選択イベントを防ぐ
                            if (confirm(`タグ「${tag}」を削除しますか？\nこのタグを持つすべてのアイテムから削除されます。`)) {
                                // すべてのアイテムからこのタグを削除
                                allItems.forEach(item => {
                                    if (item.tags && Array.isArray(item.tags)) {
                                        item.tags = item.tags.filter(t => t !== tag);
                                    }
                                });
                                GM_setValue('savedItems', allItems);
                                displaySavedItems(windowObj);
                                updateTagList();
                                updateSelectedTagsDisplay();

                                // アニメーション
                                tagDiv.animate([
                                    { transform: 'scale(1)', opacity: 1 },
                                    { transform: 'scale(0.8)', opacity: 0 }
                                ], {
                                    duration: 300,
                                    easing: 'ease-in-out'
                                }).onfinish = () => tagDiv.remove();
                            }
                        });
                    });
                };

                // 除外タグリスト更新関数は削除（除外タグ管理ウィンドウでのみ管理）

                // 選択されたタグを管理
                let selectedTags = new Set();

                // 選択されたタグ表示を更新
                const updateSelectedTagsDisplay = () => {
                    const selectedTagsContainer = selectedTagsArea.querySelector('.selectedTagsContainer');
                    if (selectedTagsContainer) {
                        selectedTagsContainer.remove();
                    }

                    const container = document.createElement('div');
                    container.className = 'selectedTagsContainer';
                    container.style.display = 'flex';
                    container.style.flexWrap = 'wrap';
                    container.style.gap = '5px';

                    selectedTags.forEach(tag => {
                        const tagDiv = document.createElement('div');
                        tagDiv.style.cssText = 'background: #16a085; padding: 3px 8px; border-radius: 10px; font-size: 11px; color: white; display: flex; align-items: center; gap: 5px;';

                        const tagText = document.createElement('span');
                        tagText.textContent = tag;

                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = '×';
                        removeBtn.style.cssText = 'background: none; border: none; color: white; cursor: pointer; font-size: 10px; padding: 0; width: 15px; height: 15px;';

                        tagDiv.append(tagText, removeBtn);
                        container.appendChild(tagDiv);

                        events.add(removeBtn, 'click', () => {
                            selectedTags.delete(tag);
                            updateSelectedTagsDisplay();
                            updateTagList();
                        });
                    });

                    selectedTagsArea.appendChild(container);
                };

                updateTagList();
                updateSelectedTagsDisplay();

                // 除外タグ追加イベント
                const handleAddExcludeTag = () => {
                    // 選択されたタグがある場合は、それらを除外
                    if (selectedTags.size > 0) {
                        const currentExcludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);
                        let addedCount = 0;

                        selectedTags.forEach(tag => {
                            const excludeRule = { pattern: tag, type: 'exact' };
                            if (!currentExcludeTags.some(t => t.pattern === tag)) {
                                currentExcludeTags.push(excludeRule);
                                addedCount++;
                            }
                        });

                        if (addedCount > 0) {
                            GM_setValue(`excludeTags-${windowObj.activeTab}`, currentExcludeTags);

                            // 既存のアイテムからこれらのタグを削除
                            const allItems = GM_getValue('savedItems', []);
                            let removedCount = 0;
                            allItems.forEach(item => {
                                if (item.tab === windowObj.activeTab && item.tags && Array.isArray(item.tags)) {
                                    const originalTags = [...item.tags];
                                    item.tags = item.tags.filter(tag => !selectedTags.has(tag));
                                    if (item.tags.length !== originalTags.length) {
                                        removedCount++;
                                    }
                                }
                            });

                            GM_setValue('savedItems', allItems);
                            displaySavedItems(windowObj);
                            updateTagList();
                            selectedTags.clear();
                            updateSelectedTagsDisplay();

                            // タグフィルターを即座に更新
                            updateTagFilterButtons(windowObj);

                            logMessage(`${addedCount}個のタグを除外し、${removedCount}件のアイテムから削除しました`);
                        }
                    } else {
                        // 手動入力の場合
                        const excludeTagName = excludeInput.value.trim();
                        if (!excludeTagName) return;

                        if (excludeTagName.length > 50) {
                            alert('除外タグ名は50文字以内で入力してください。');
                            return;
                        }

                        const excludeType = document.querySelector('input[name="excludeType"]:checked').value;

                        // 正規表現の場合はバリデーション
                        if (excludeType === 'regex') {
                            try {
                                new RegExp(excludeTagName);
                            } catch (e) {
                                alert('正規表現が無効です。');
                                return;
                            }
                        }

                        const currentExcludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);
                        const excludeRule = { pattern: excludeTagName, type: excludeType };

                        if (currentExcludeTags.some(t => t.pattern === excludeTagName)) {
                            alert('この除外タグは既に設定されています。');
                            return;
                        }

                        // 除外タグを追加
                        currentExcludeTags.push(excludeRule);
                        GM_setValue(`excludeTags-${windowObj.activeTab}`, currentExcludeTags);

                        // 既存のアイテムからこのタグを削除
                        const allItems = GM_getValue('savedItems', []);
                        let removedCount = 0;
                        allItems.forEach(item => {
                            if (item.tab === windowObj.activeTab && item.tags && Array.isArray(item.tags)) {
                                const originalTags = [...item.tags];
                                item.tags = item.tags.filter(tag => {
                                    if (excludeType === 'regex') {
                                        try {
                                            return !new RegExp(excludeTagName).test(tag);
                                        } catch (e) {
                                            return true;
                                        }
                                    } else {
                                        return tag !== excludeTagName;
                                    }
                                });
                                if (item.tags.length !== originalTags.length) {
                                    removedCount++;
                                }
                            }
                        });

                        GM_setValue('savedItems', allItems);
                        displaySavedItems(windowObj);
                        updateTagList();
                        excludeInput.value = '';

                        // タグフィルターを即座に更新
                        updateTagFilterButtons(windowObj);

                        logMessage(`除外タグ「${excludeTagName}」(${excludeType === 'regex' ? '正規表現' : '完全一致'})を追加し、${removedCount}件のアイテムから削除しました`);
                    }

                    // アニメーション
                    addExcludeBtn.animate([
                        { transform: 'scale(1)' },
                        { transform: 'scale(1.1)' },
                        { transform: 'scale(1)' }
                    ], {
                        duration: 200,
                        easing: 'ease-in-out'
                    });
                };

                events.add(addExcludeBtn, 'click', handleAddExcludeTag);
                events.add(excludeInput, 'keypress', (e) => {
                    if (e.key === 'Enter') handleAddExcludeTag();
                });

                // グループ管理機能
                const updateGroupList = () => {
                    groupList.innerHTML = '';
                    const tagGroups = GM_getValue(`tagGroups-${windowObj.activeTab}`, {});

                    Object.entries(tagGroups).forEach(([groupName, groupTags]) => {
                        const groupDiv = document.createElement('div');
                        groupDiv.style.cssText = 'background: #0a1f2e; padding: 10px; border-radius: 5px; border: 1px solid #104437;';

                        const groupHeader = document.createElement('div');
                        groupHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;';

                        const groupTitle = document.createElement('h5');
                        groupTitle.textContent = groupName;
                        groupTitle.style.cssText = 'margin: 0; color: #16a085; font-size: 14px;';

                        const deleteGroupBtn = document.createElement('button');
                        deleteGroupBtn.textContent = '削除';
                        deleteGroupBtn.style.cssText = 'background: #e74c3c; border: none; color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;';

                        groupHeader.append(groupTitle, deleteGroupBtn);

                        const groupTagsDiv = document.createElement('div');
                        groupTagsDiv.style.cssText = 'display: flex; flex-wrap: wrap; gap: 5px;';

                        groupTags.forEach(tag => {
                            const tagSpan = document.createElement('span');
                            tagSpan.textContent = tag;
                            tagSpan.style.cssText = 'background: #104437; padding: 2px 6px; border-radius: 8px; font-size: 10px; color: white;';
                            groupTagsDiv.appendChild(tagSpan);
                        });

                        groupDiv.append(groupHeader, groupTagsDiv);
                        groupList.appendChild(groupDiv);

                        // グループ削除イベント
                        events.add(deleteGroupBtn, 'click', () => {
                            if (confirm(`グループ「${groupName}」を削除しますか？`)) {
                                delete tagGroups[groupName];
                                GM_setValue(`tagGroups-${windowObj.activeTab}`, tagGroups);
                                updateGroupList();

                                // タグフィルターを即座に更新
                                updateTagFilterButtons(windowObj);

                                // アニメーション
                                groupDiv.animate([
                                    { transform: 'scale(1)', opacity: 1 },
                                    { transform: 'scale(0.8)', opacity: 0 }
                                ], {
                                    duration: 300,
                                    easing: 'ease-in-out'
                                }).onfinish = () => groupDiv.remove();
                            }
                        });
                    });
                };

                updateGroupList();

                // グループ作成イベント
                const handleCreateGroup = () => {
                    const groupName = groupInput.value.trim();
                    if (!groupName) {
                        alert('グループ名を入力してください。');
                        return;
                    }

                    if (selectedTags.size === 0) {
                        alert('グループに含めるタグを選択してください。');
                        return;
                    }

                    const tagGroups = GM_getValue(`tagGroups-${windowObj.activeTab}`, {});
                    if (tagGroups[groupName]) {
                        alert('このグループ名は既に存在します。');
                        return;
                    }

                    // グループを作成
                    tagGroups[groupName] = Array.from(selectedTags);
                    GM_setValue(`tagGroups-${windowObj.activeTab}`, tagGroups);

                    // 選択をクリア
                    selectedTags.clear();
                    groupInput.value = '';

                    updateGroupList();
                    updateTagList();
                    updateSelectedTagsDisplay();

                    // タグフィルターを即座に更新
                    updateTagFilterButtons(windowObj);

                    // アニメーション
                    createGroupBtn.animate([
                        { transform: 'scale(1)' },
                        { transform: 'scale(1.1)' },
                        { transform: 'scale(1)' }
                    ], {
                        duration: 200,
                        easing: 'ease-in-out'
                    });

                    logMessage(`グループ「${groupName}」を作成しました（${Array.from(selectedTags).length}個のタグ）`);
                };

                events.add(createGroupBtn, 'click', handleCreateGroup);
                events.add(groupInput, 'keypress', (e) => {
                    if (e.key === 'Enter') handleCreateGroup();
                });

                // タグ追加イベント
                const handleAddTag = () => {
                    const tagName = tagInput.value.trim();
                    if (!tagName) return;

                    if (tagName.length > 20) {
                        alert('タグ名は20文字以内で入力してください。');
                        return;
                    }

                    // 既存のタグかチェック
                    const allItems = GM_getValue('savedItems', []);
                    const currentTabItems = allItems.filter(item => item.tab === windowObj.activeTab);
                    const existingTags = new Set();
                    currentTabItems.forEach(item => {
                        if (item.tags && Array.isArray(item.tags)) {
                            item.tags.forEach(tag => existingTags.add(tag));
                        }
                    });

                    if (existingTags.has(tagName)) {
                        alert('このタグは既に存在します。');
                        return;
                    }

                    // 除外タグかチェック
                    const excludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);
                    const isExcluded = excludeTags.some(excludeRule => {
                        if (excludeRule.type === 'regex') {
                            try {
                                return new RegExp(excludeRule.pattern).test(tagName);
                            } catch (e) {
                                return false;
                            }
                        } else {
                            return excludeRule.pattern === tagName;
                        }
                    });

                    if (isExcluded) {
                        alert(`「${tagName}」は除外タグとして設定されているため、追加できません。`);
                        return;
                    }

                    // 選択されたアイテムにタグを追加
                    const selectedItems = windowObj.el.querySelectorAll('.savedItem.selected');
                    if (selectedItems.length === 0) {
                        alert('タグを追加するアイテムを選択してください。\n編集モードでアイテムを選択してからタグを追加してください。');
                        return;
                    }

                    selectedItems.forEach(item => {
                        const timestamp = item.dataset.timestamp;
                        const itemData = allItems.find(i => i.timestamp === timestamp);
                        if (itemData) {
                            if (!itemData.tags) itemData.tags = [];
                            if (!itemData.tags.includes(tagName)) {
                                itemData.tags.push(tagName);
                            }
                        }
                    });

                    GM_setValue('savedItems', allItems);
                    displaySavedItems(windowObj);
                    updateTagList();
                    tagInput.value = '';

                    // アニメーション
                    addBtn.animate([
                        { transform: 'scale(1)' },
                        { transform: 'scale(1.1)' },
                        { transform: 'scale(1)' }
                    ], {
                        duration: 200,
                        easing: 'ease-in-out'
                    });

                    logMessage(`タグ「${tagName}」を${selectedItems.length}件のアイテムに追加`);
                };

                events.add(addBtn, 'click', handleAddTag);
                events.add(tagInput, 'keypress', (e) => {
                    if (e.key === 'Enter') handleAddTag();
                });
                events.add(closeBtn, 'click', () => { tagEditDiv.remove(); state.activePopup = null; });

                return tagEditDiv;
            };

            const updateTagFilterButtons = (windowObj) => {
                const tagFilterArea = windowObj.el.querySelector('.tagFilterArea');
                if (!tagFilterArea) return;

                // 既存のタグボタンをクリア
                tagFilterArea.innerHTML = '';

                // 非同期でタグ処理を実行
                requestAnimationFrame(() => {
                    // 現在のタブのすべてのタグを取得（除外タグを除く）
                    const allItems = GM_getValue('savedItems', []);
                    const currentTabItems = allItems.filter(item => item.tab === windowObj.activeTab);
                    const excludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);
                    const allTags = new Set();

                    // タグ収集を最適化
                    const tagCount = new Map();
                    currentTabItems.forEach(item => {
                        if (item.tags && Array.isArray(item.tags)) {
                            item.tags.forEach(tag => {
                                // 除外タグにマッチしないもののみ追加
                                const isExcluded = excludeTags.some(rule => {
                                    if (rule.type === 'regex') {
                                        try {
                                            return new RegExp(rule.pattern).test(tag);
                                        } catch (e) {
                                            return false;
                                        }
                                    } else {
                                        return tag === rule.pattern;
                                    }
                                });

                                if (!isExcluded) {
                                    allTags.add(tag);
                                    tagCount.set(tag, (tagCount.get(tag) || 0) + 1);
                                }
                            });
                        }
                    });

                    // 除外タグは既に取得済み

                    // タググループを取得
                    const tagGroups = GM_getValue(`tagGroups-${windowObj.activeTab}`, {});

                    // 選択されたタグを初期化
                    if (!windowObj.selectedTags) windowObj.selectedTags = new Set();

                    // グループに含まれているタグを取得
                    const groupedTags = new Set();
                    Object.values(tagGroups).forEach(groupTags => {
                        groupTags.forEach(tag => groupedTags.add(tag));
                    });

                    // グループに含まれていないタグを取得
                    const ungroupedTags = Array.from(allTags).filter(tag => !groupedTags.has(tag));

                    // グループごとにセクションを作成
                    Object.entries(tagGroups).forEach(([groupName, groupTags]) => {
                        // グループ内のタグボタンを作成（1列でコンパクト化）
                        const groupTagsContainer = document.createElement('div');
                        groupTagsContainer.style.cssText = `
                            display: flex;
                            flex-wrap: wrap;
                            gap: 3px;
                            margin-bottom: 8px;
                        `;

                        groupTags.forEach(tag => {
                            const tagBtn = document.createElement('button');
                            tagBtn.className = 'tagFilterBtn';
                            tagBtn.textContent = tag;
                            tagBtn.style.cssText = `
                                background: ${windowObj.selectedTags.has(tag) ? '#e67e22' : '#104437'};
                                color: white;
                                border: none;
                                padding: 3px 6px;
                                border-radius: 10px;
                                font-size: 10px;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                            `;

                            // タグボタンクリックイベント
                            events.add(tagBtn, 'click', () => {
                                if (windowObj.multiSelectMode) {
                                    // 複数選択モード：タグを追加/削除
                                    if (windowObj.selectedTags.has(tag)) {
                                        // タグを解除
                                        windowObj.selectedTags.delete(tag);
                                        tagBtn.style.background = '#104437';

                                        // アニメーション
                                        tagBtn.animate([
                                            { transform: 'scale(1)' },
                                            { transform: 'scale(0.9)' },
                                            { transform: 'scale(1)' }
                                        ], {
                                            duration: 200,
                                            easing: 'ease-in-out'
                                        });
                                    } else {
                                        // タグを選択
                                        windowObj.selectedTags.add(tag);
                                        tagBtn.style.background = '#e67e22';

                                        // アニメーション
                                        tagBtn.animate([
                                            { transform: 'scale(1)' },
                                            { transform: 'scale(1.1)' },
                                            { transform: 'scale(1)' }
                                        ], {
                                            duration: 200,
                                            easing: 'ease-in-out'
                                        });
                                    }
                                } else {
                                    // 通常モード：前の選択をクリアして新しいタグのみ選択
                                    windowObj.selectedTags.clear();
                                    windowObj.selectedTags.add(tag);

                                    // すべてのタグボタンの色をリセット
                                    tagFilterArea.querySelectorAll('.tagFilterBtn').forEach(btn => {
                                        btn.style.background = '#104437';
                                    });

                                    // 選択されたタグボタンの色を変更
                                    tagBtn.style.background = '#e67e22';

                                    // アニメーション
                                    tagBtn.animate([
                                        { transform: 'scale(1)' },
                                        { transform: 'scale(1.1)' },
                                        { transform: 'scale(1)' }
                                    ], {
                                        duration: 200,
                                        easing: 'ease-in-out'
                                    });
                                }

                                // アイテムを再表示
                                displaySavedItems(windowObj);

                                // 選択状態を保存
                                GM_setValue(`selectedTags-${windowObj.activeTab}`, Array.from(windowObj.selectedTags));

                                // クリアボタンの表示/非表示を更新（重複を防ぐため）
                                if (windowObj.selectedTags.size === 1) {
                                    // 初回選択時のみクリアボタンを更新
                                    updateClearButton(windowObj);
                                } else if (windowObj.selectedTags.size === 0) {
                                    // 選択解除時はクリアボタンを削除
                                    updateClearButton(windowObj);
                                }

                                logMessage(`タグフィルター: ${Array.from(windowObj.selectedTags).join(', ')}`);
                            });

                            groupTagsContainer.appendChild(tagBtn);
                        });

                        tagFilterArea.appendChild(groupTagsContainer);
                    });

                    // その他のタグセクションは削除（グループに属さないタグは表示しない）

                    // 除外タグ情報表示（非表示）
                    // 除外タグは別ウィンドウで管理するため、ここでは表示しない

                    // クリアボタンの表示/非表示を更新
                    updateClearButton(windowObj);
                });

                // 除外タグは既に取得済み

                // タググループを取得
                const tagGroups = GM_getValue(`tagGroups-${windowObj.activeTab}`, {});

                // 選択されたタグを初期化
                if (!windowObj.selectedTags) windowObj.selectedTags = new Set();

                // グループに含まれているタグを取得
                const groupedTags = new Set();
                Object.values(tagGroups).forEach(groupTags => {
                    groupTags.forEach(tag => groupedTags.add(tag));
                });

                // グループに含まれていないタグを取得
                const ungroupedTags = Array.from(allTags).filter(tag => !groupedTags.has(tag));

                // グループごとにセクションを作成
                Object.entries(tagGroups).forEach(([groupName, groupTags]) => {
                    // グループ内のタグボタンを作成（1列でコンパクト化）
                    const groupTagsContainer = document.createElement('div');
                    groupTagsContainer.style.cssText = `
                        display: flex;
                        flex-wrap: wrap;
                        gap: 3px;
                        margin-bottom: 8px;
                    `;

                    groupTags.forEach(tag => {
                        const tagBtn = document.createElement('button');
                        tagBtn.className = 'tagFilterBtn';
                        tagBtn.textContent = tag;
                        tagBtn.style.cssText = `
                            background: ${windowObj.selectedTags.has(tag) ? '#e67e22' : '#104437'};
                            color: white;
                            border: none;
                            padding: 3px 6px;
                            border-radius: 10px;
                            font-size: 10px;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                        `;

                        // タグボタンクリックイベント
                        events.add(tagBtn, 'click', () => {
                            if (windowObj.multiSelectMode) {
                                // 複数選択モード：タグを追加/削除
                                if (windowObj.selectedTags.has(tag)) {
                                    // タグを解除
                                    windowObj.selectedTags.delete(tag);
                                    tagBtn.style.background = '#104437';

                                    // アニメーション
                                    tagBtn.animate([
                                        { transform: 'scale(1)' },
                                        { transform: 'scale(0.9)' },
                                        { transform: 'scale(1)' }
                                    ], {
                                        duration: 200,
                                        easing: 'ease-in-out'
                                    });
                                } else {
                                    // タグを選択
                                    windowObj.selectedTags.add(tag);
                                    tagBtn.style.background = '#e67e22';

                                    // アニメーション
                                    tagBtn.animate([
                                        { transform: 'scale(1)' },
                                        { transform: 'scale(1.1)' },
                                        { transform: 'scale(1)' }
                                    ], {
                                        duration: 200,
                                        easing: 'ease-in-out'
                                    });
                                }
                            } else {
                                // 通常モード：前の選択をクリアして新しいタグのみ選択
                                windowObj.selectedTags.clear();
                                windowObj.selectedTags.add(tag);

                                // すべてのタグボタンの色をリセット
                                tagFilterArea.querySelectorAll('.tagFilterBtn').forEach(btn => {
                                    btn.style.background = '#104437';
                                });

                                // 選択されたタグボタンの色を変更
                                tagBtn.style.background = '#e67e22';

                                // アニメーション
                                tagBtn.animate([
                                    { transform: 'scale(1)' },
                                    { transform: 'scale(1.1)' },
                                    { transform: 'scale(1)' }
                                ], {
                                    duration: 200,
                                    easing: 'ease-in-out'
                                });
                            }

                            // アイテムを再表示
                            displaySavedItems(windowObj);

                            // 選択状態を保存
                            GM_setValue(`selectedTags-${windowObj.activeTab}`, Array.from(windowObj.selectedTags));

                            // クリアボタンの表示/非表示を更新（重複を防ぐため）
                            if (windowObj.selectedTags.size === 1) {
                                // 初回選択時のみクリアボタンを更新
                                updateClearButton(windowObj);
                            } else if (windowObj.selectedTags.size === 0) {
                                // 選択解除時はクリアボタンを削除
                                updateClearButton(windowObj);
                            }

                            logMessage(`タグフィルター: ${Array.from(windowObj.selectedTags).join(', ')}`);
                        });

                        groupTagsContainer.appendChild(tagBtn);
                    });

                    tagFilterArea.appendChild(groupTagsContainer);
                });

                // その他のタグセクションは削除（グループに属さないタグは表示しない）

                // 除外タグ情報表示（非表示）
                // 除外タグは別ウィンドウで管理するため、ここでは表示しない

                // クリアボタンの表示/非表示を更新
                updateClearButton(windowObj);
            };

            const updateClearButton = (windowObj) => {
                // 既存のクリアボタンをすべて削除（より確実に）
                const existingClearBtns = windowObj.el.querySelectorAll('.clearFilterButton');
                existingClearBtns.forEach(btn => {
                    // イベントリスナーも削除
                    events.removeAll(btn);
                    btn.remove();
                });

                // タグ編集ボタンの横にあるクリアボタンも削除（念のため）
                const tagEditButton = windowObj.el.querySelector('.tagEditButton');
                if (tagEditButton) {
                    // タグ編集ボタンの後にあるすべての兄弟要素をチェック
                    let nextSibling = tagEditButton.nextSibling;
                    while (nextSibling) {
                        if (nextSibling.textContent === 'クリア' || nextSibling.className === 'clearFilterButton') {
                            events.removeAll(nextSibling);
                            const tempSibling = nextSibling.nextSibling;
                            nextSibling.remove();
                            nextSibling = tempSibling;
                        } else {
                            nextSibling = nextSibling.nextSibling;
                        }
                    }
                }

                // 選択されたタグがある場合のみクリアボタンを表示
                if (windowObj.selectedTags && windowObj.selectedTags.size > 0) {
                    const clearBtn = document.createElement('button');
                    clearBtn.className = 'clearFilterButton';
                    clearBtn.textContent = 'クリア';
                    clearBtn.style.cssText = `
                        background: #e74c3c;
                        color: white;
                        border: none;
                        padding: 3px 8px;
                        border-radius: 12px;
                        font-size: 10px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        margin-left: 5px;
                    `;

                    events.add(clearBtn, 'click', () => {
                        windowObj.selectedTags.clear();
                        GM_setValue(`selectedTags-${windowObj.activeTab}`, []);
                        displaySavedItems(windowObj);
                        updateClearButton(windowObj); // クリアボタンを非表示にする

                        // アニメーション
                        clearBtn.animate([
                            { transform: 'scale(1)' },
                            { transform: 'scale(1.1)' },
                            { transform: 'scale(1)' }
                        ], {
                            duration: 200,
                            easing: 'ease-in-out'
                        });

                        logMessage('タグフィルターをクリアしました');
                    });

                    // クリアボタンをタグ編集ボタンの横に追加
                    const tagEditButton = windowObj.el.querySelector('.tagEditButton');
                    if (tagEditButton) {
                        // 既にクリアボタンが存在しないことを確認してから追加
                        const existingClearBtn = tagEditButton.parentNode.querySelector('.clearFilterButton');
                        if (!existingClearBtn) {
                            tagEditButton.parentNode.insertBefore(clearBtn, tagEditButton.nextSibling);
                        } else {
                            // 既に存在する場合は新しいボタンを削除
                            events.removeAll(clearBtn);
                            clearBtn.remove();
                        }
                    }
                }
            };

            // 汎用ポップアップウィンドウ作成関数
            const createPopupWindow = (options) => {
                const {
                    title,
                    width = 350,
                    height = 300,
                    className = 'popupWindow',
                    content
                } = options;

                if (state.activePopup) {
                    state.activePopup.remove();
                }

                const popupDiv = document.createElement('div');
                popupDiv.className = className;
                popupDiv.style.cssText = `
                    position: fixed;
                    background-color: #082849;
                    border: 2px solid #104437;
                    padding: 5px;
                    z-index: 10001;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    font-family: sans-serif;
                    color: #fff;
                    width: ${width}px;
                    height: ${height}px;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    overflow-y: auto;
                `;

                const menuBar = document.createElement('div');
                menuBar.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    padding: 2px;
                    background-color: #104437;
                    height: 20px;
                    align-items: center;
                `;

                const titleElement = document.createElement('h3');
                titleElement.textContent = title;
                titleElement.style.cssText = 'margin: 0; flex-grow: 1; text-align: center; font-size: 14px;';

                const closeBtn = document.createElement('button');
                closeBtn.textContent = '×';
                closeBtn.style.cssText = 'padding: 1px 3px; background-color: #082849; color: #fff; border: none; cursor: pointer; border-radius: 3px; font-size: 12px;';

                menuBar.append(titleElement, closeBtn);
                popupDiv.appendChild(menuBar);

                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = 'overflow-y: auto; padding: 15px;';

                if (typeof content === 'function') {
                    content(contentDiv);
                } else {
                    contentDiv.appendChild(content);
                }

                popupDiv.appendChild(contentDiv);
                document.body.appendChild(popupDiv);
                state.activePopup = popupDiv;
                bringToFrontPopup(popupDiv);

                events.add(closeBtn, 'click', () => {
                    popupDiv.remove();
                    state.activePopup = null;
                });

                return popupDiv;
            };

            const createDomainDisplayWindow = (windowObj) => {
                return createPopupWindow({
                    title: 'ドメイン名表示設定',
                    className: 'domainDisplayPopup',
                    content: (contentDiv) => {
                        // 説明文
                        const description = document.createElement('div');
                        description.textContent = 'タブでドメイン名を横文字で表示するか、ファビコンで表示するかを設定できます。';
                        description.style.cssText = 'margin-bottom: 15px; font-size: 12px; color: #95a5a6; line-height: 1.4;';

                        // 設定オプション
                        const settingsDiv = document.createElement('div');
                        settingsDiv.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';

                        // ドメイン名表示設定
                        const domainDisplaySetting = document.createElement('div');
                        domainDisplaySetting.style.cssText = 'display: flex; align-items: center; gap: 10px;';

                        const domainDisplayLabel = document.createElement('label');
                        domainDisplayLabel.textContent = 'ドメイン名を横文字で表示:';
                        domainDisplayLabel.style.cssText = 'font-size: 12px; flex-grow: 1;';

                        const domainDisplayCheckbox = document.createElement('input');
                        domainDisplayCheckbox.type = 'checkbox';
                        domainDisplayCheckbox.id = 'domainDisplayCheckbox';

                        // 現在の設定を読み込む
                        const currentDomainDisplay = GM_getValue('domainDisplayMode', false);
                        domainDisplayCheckbox.checked = currentDomainDisplay;

                        domainDisplaySetting.append(domainDisplayLabel, domainDisplayCheckbox);
                        settingsDiv.appendChild(domainDisplaySetting);

                        // 保存ボタン
                        const saveBtn = document.createElement('button');
                        saveBtn.textContent = '設定を保存';
                        saveBtn.style.cssText = `
                            background: #27ae60;
                            color: white;
                            border: none;
                            padding: 8px 15px;
                            border-radius: 5px;
                            font-size: 12px;
                            cursor: pointer;
                            margin-top: 15px;
                            width: 100%;
                        `;

                        events.add(saveBtn, 'click', () => {
                            const newDomainDisplay = domainDisplayCheckbox.checked;
                            GM_setValue('domainDisplayMode', newDomainDisplay);

                            // タブ表示を更新
                            if (state.window) {
                                updateTabs(state.window);
                            }

                            // アニメーション
                            saveBtn.animate([
                                { transform: 'scale(1)' },
                                { transform: 'scale(1.05)' },
                                { transform: 'scale(1)' }
                            ], {
                                duration: 200,
                                easing: 'ease-in-out'
                            });

                            logMessage(`ドメイン名表示設定を保存: ${newDomainDisplay ? '横文字' : 'ファビコン'}`);
                            alert('設定を保存しました。');
                        });

                        contentDiv.append(description, settingsDiv, saveBtn);
                    }
                });
            };

            const createExcludeManageWindow = (windowObj) => {
                return createPopupWindow({
                    title: '除外タグ管理',
                    width: 400,
                    height: 500,
                    className: 'excludeManagePopup',
                    content: (contentDiv) => {

                // 除外タグ一覧
                const excludeList = document.createElement('div');
                excludeList.id = 'excludeManageList';
                excludeList.style.cssText = 'margin-bottom: 15px;';

                const updateExcludeManageList = () => {
                    excludeList.innerHTML = '';
                    const excludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);

                    if (excludeTags.length === 0) {
                        const noExcludeMsg = document.createElement('div');
                        noExcludeMsg.textContent = '除外されたタグはありません';
                        noExcludeMsg.style.cssText = 'text-align: center; color: #95a5a6; padding: 20px;';
                        excludeList.appendChild(noExcludeMsg);
                        return;
                    }

                    excludeTags.forEach((rule, index) => {
                        const excludeDiv = document.createElement('div');
                        excludeDiv.style.cssText = `
                            background: #0a1f2e;
                            padding: 10px;
                            border-radius: 5px;
                            border: 1px solid #104437;
                            margin-bottom: 8px;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        `;

                        const excludeInfo = document.createElement('div');
                        excludeInfo.style.cssText = 'flex-grow: 1;';

                        const excludePattern = document.createElement('div');
                        excludePattern.textContent = rule.pattern;
                        excludePattern.style.cssText = 'font-weight: bold; color: #e74c3c; margin-bottom: 2px;';

                        const excludeType = document.createElement('div');
                        excludeType.textContent = rule.type === 'regex' ? '正規表現' : '完全一致';
                        excludeType.style.cssText = 'font-size: 10px; color: #95a5a6;';

                        excludeInfo.appendChild(excludePattern);
                        excludeInfo.appendChild(excludeType);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.textContent = '削除';
                        deleteBtn.style.cssText = 'background: #e74c3c; border: none; color: white; padding: 3px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;';

                        excludeDiv.appendChild(excludeInfo);
                        excludeDiv.appendChild(deleteBtn);
                        excludeList.appendChild(excludeDiv);

                        // 削除イベント
                        events.add(deleteBtn, 'click', () => {
                            if (confirm(`除外タグ「${rule.pattern}」を削除しますか？`)) {
                                excludeTags.splice(index, 1);
                                GM_setValue(`excludeTags-${windowObj.activeTab}`, excludeTags);
                                updateExcludeManageList();

                                // アニメーション
                                excludeDiv.animate([
                                    { transform: 'scale(1)', opacity: 1 },
                                    { transform: 'scale(0.8)', opacity: 0 }
                                ], {
                                    duration: 300,
                                    easing: 'ease-in-out'
                                }).onfinish = () => excludeDiv.remove();

                                logMessage(`除外タグ「${rule.pattern}」を削除しました`);
                            }
                        });
                    });
                };

                updateExcludeManageList();
                content.appendChild(excludeList);

                // 復元機能
                const restoreSection = document.createElement('div');
                restoreSection.style.cssText = 'border-top: 1px solid #104437; padding-top: 15px;';

                const restoreTitle = document.createElement('h4');
                restoreTitle.textContent = '除外タグを復元';
                restoreTitle.style.cssText = 'margin: 0 0 10px 0; color: #16a085; font-size: 12px;';

                const restoreBtn = document.createElement('button');
                restoreBtn.textContent = 'すべての除外タグを復元';
                restoreBtn.style.cssText = `
                    background: #16a085;
                    color: white;
                    border: none;
                    padding: 8px 12px;
                    border-radius: 5px;
                    font-size: 11px;
                    cursor: pointer;
                    width: 100%;
                `;

                events.add(restoreBtn, 'click', () => {
                    if (confirm('すべての除外タグを復元しますか？\n除外されたタグがアイテムに再び追加されます。')) {
                        const excludeTags = GM_getValue(`excludeTags-${windowObj.activeTab}`, []);
                        const allItems = GM_getValue('savedItems', []);
                        let restoredCount = 0;

                        allItems.forEach(item => {
                            if (item.tab === windowObj.activeTab) {
                                excludeTags.forEach(rule => {
                                    if (rule.type === 'regex') {
                                        try {
                                            const regex = new RegExp(rule.pattern);
                                            if (regex.test(item.title) && !item.tags.includes(rule.pattern)) {
                                                if (!item.tags) item.tags = [];
                                                item.tags.push(rule.pattern);
                                                restoredCount++;
                                            }
                                        } catch (e) {
                                            // 正規表現エラーは無視
                                        }
                                    } else {
                                        if (item.title.includes(rule.pattern) && !item.tags.includes(rule.pattern)) {
                                            if (!item.tags) item.tags = [];
                                            item.tags.push(rule.pattern);
                                            restoredCount++;
                                        }
                                    }
                                });
                            }
                        });

                        GM_setValue('savedItems', allItems);
                        displaySavedItems(windowObj);
                        updateExcludeManageList();

                        logMessage(`${restoredCount}個のタグを復元しました`);
                    }
                });

                        restoreSection.appendChild(restoreTitle);
                        restoreSection.appendChild(restoreBtn);
                        contentDiv.appendChild(restoreSection);

                        logMessage('除外タグ管理ウィンドウを開きました');
                    }
                });
            };

            const showDataSizeInfo = (windowObj) => {
                const allItems = GM_getValue('savedItems', []);
                const currentTabItems = allItems.filter(item => item.tab === windowObj.activeTab);

                let totalSize = 0;
                const itemSizes = currentTabItems.map(item => {
                    const itemData = JSON.stringify(item);
                    const size = new Blob([itemData]).size;
                    totalSize += size;
                    return {
                        title: item.title,
                        size: size,
                        imageSize: item.image ? new Blob([item.image]).size : 0
                    };
                });

                const totalSizeKB = (totalSize / 1024).toFixed(2);
                const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);

                let message = `📊 データ量情報 (${windowObj.activeTab})\n\n`;
                message += `総アイテム数: ${currentTabItems.length}件\n`;
                message += `総データ量: ${totalSizeKB} KB (${totalSizeMB} MB)\n\n`;

                if (itemSizes.length > 0) {
                    message += `📋 個別アイテム詳細:\n`;
                    itemSizes.forEach((item, index) => {
                        const itemSizeKB = (item.size / 1024).toFixed(2);
                        const imageSizeKB = (item.imageSize / 1024).toFixed(2);
                        message += `${index + 1}. ${item.title.substring(0, 30)}...\n`;
                        message += `   総サイズ: ${itemSizeKB} KB (画像: ${imageSizeKB} KB)\n`;
                    });
                }

                // ストレージ容量の推定
                const estimatedLimit = 5 * 1024 * 1024; // 5MB推定
                const remainingSpace = estimatedLimit - totalSize;
                const remainingMB = (remainingSpace / (1024 * 1024)).toFixed(2);

                message += `\n💾 ストレージ状況:\n`;
                message += `使用量: ${totalSizeMB} MB\n`;
                message += `推定残り容量: ${remainingMB} MB\n`;
                message += `使用率: ${((totalSize / estimatedLimit) * 100).toFixed(1)}%`;

                alert(message);
                logMessage(`データ量情報表示: ${currentTabItems.length}件, ${totalSizeKB}KB`);
            };

            const init = () => {
                // 動画フレーム内での実行をチェック
                const isInVideoFrame = () => {
                    try {
                        // iframe内かチェック
                        if (window !== window.top) {
                            return true;
                        }

                        // 動画プレーヤー内かチェック
                        const videoSelectors = [
                            'video',
                            'iframe[src*="player"]',
                            'iframe[src*="video"]',
                            'iframe[src*="embed"]',
                            '.video-player',
                            '.player-container',
                            '[class*="player"]',
                            '[id*="player"]'
                        ];

                        const videoElements = document.querySelectorAll(videoSelectors.join(','));
                        for (const element of videoElements) {
                            if (element.contains(document.body) || element === document.body) {
                                return true;
                            }
                        }

                        // 動画サイト特有のURLパターンチェック
                        const videoSitePatterns = [
                            /youtube\.com\/embed\//,
                            /vimeo\.com\/embed\//,
                            /dailymotion\.com\/embed\//,
                            /player\./,
                            /embed\./
                        ];

                        return videoSitePatterns.some(pattern => pattern.test(window.location.href));
                    } catch (e) {
                        return false;
                    }
                };

                // 動画フレーム内の場合は初期化をスキップ
                if (isInVideoFrame()) {
                    logMessage("動画フレーム内を検出、ツールバー初期化をスキップ");
                    return;
                }

                // 初期化前の状態バリデーション
                state.validateState();

                // ツールバーの初期化
                const toolbarElements = safeExecute(() => Toolbar.init(), null, () => {
                    logMessage("ツールバー初期化に失敗しました", 'error');
                    return null;
                });

                if (!toolbarElements) {
                    logMessage("ツールバー初期化失敗、中止", 'error');
                    return;
                }

                // ツールバー位置の設定
                let toolbarLeft, toolbarTop;
                safeExecute(() => {
                    toolbarLeft = Math.max(0, Math.min(window.innerWidth - 80, parseFloat(GM_getValue('toolbarPosition', { left: window.innerWidth - 80 }).left) || 0));
                    toolbarTop = Math.max(0, Math.min(window.innerHeight - 100, parseFloat(GM_getValue('toolbarPosition', { top: 50 }).top) || 50));
                    toolbarElements.toolbar.style.left = `${toolbarLeft}px`;
                    toolbarElements.toolbar.style.top = `${toolbarTop}px`;
                    toolbarElements.toolbar.style.right = 'auto';
                    logMessage("ツールバー位置設定完了");
                });

                // フルスクリーン検知
                events.add(document, 'fullscreenchange', () => {
                    safeExecute(() => {
                        if (document.fullscreenElement) {
                            toolbarElements.toolbar.style.display = 'none';
                            logMessage("フルスクリーン検知: ツールバーを非表示");
                        } else {
                            toolbarElements.toolbar.style.display = 'block';
                            logMessage("フルスクリーン解除: ツールバーを表示");
                        }
                    });
                });

                // 保存されたウィンドウの復元
                safeExecute(() => {
                    const savedWindowId = GM_getValue('savedWindow', null);
                    if (savedWindowId) {
                        const savedState = GM_getValue(`windowState-${savedWindowId}`, { position: { left: '21px', top: '23px' }, size: { width: '950px', height: '550px' } });
                        const windowObj = Window.create(savedWindowId, savedState);
                        if (windowObj) state.setWindow(windowObj);
                    }
                });

                // ウィンドウリサイズ処理の最適化
                let resizeTimeout;
                window.onresize = () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        safeExecute(() => {
                            // 現在のツールバー位置を取得
                            const currentLeft = toolbarElements.toolbar.style.left;
                            const currentTop = toolbarElements.toolbar.style.top;
                            const toolbarPos = GM_getValue('toolbarPosition', { left: currentLeft, top: currentTop });

                            toolbarElements.toolbar.style.left = `${Math.max(0, Math.min(parseFloat(toolbarPos.left), window.innerWidth - 80))}px`;
                            toolbarElements.toolbar.style.top = `${Math.max(0, Math.min(parseFloat(toolbarPos.top), window.innerHeight - 100))}px`;

                            if (state.window && state.window.isMaximized) {
                                const maximizeBtn = state.window.el.querySelector('.maximizeButton');
                                if (maximizeBtn) maximizeBtn.click();
                            }
                        });
                    }, 100); // デバウンス処理
                };

                // ページ離脱時のクリーンアップ
                window.addEventListener('beforeunload', () => {
                    safeExecute(() => {
                        state.resetTemporaryState();
                        Memoization.clearCache();
                        logMessage("アプリケーション終了時のクリーンアップ完了");
                    });
                });

                logMessage("初期化完了");

                // 通知アニメーション用のCSS追加
                const notificationCSS = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                    @keyframes fadeIn {
                        from { opacity: 0; transform: scale(0.9); }
                        to { opacity: 1; transform: scale(1); }
                    }
                    @keyframes pulse {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.05); }
                        100% { transform: scale(1); }
                    }
                    .ash8-notification {
                        animation: slideIn 0.3s ease-out;
                    }
                    .savedItem {
                        transition: all 0.2s ease;
                    }
                    .savedItem:hover {
                        transform: translateY(-2px);
                        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    }
                    .tab-vertical {
                        transition: all 0.2s ease;
                    }
                    .tab-vertical:hover {
                        transform: scale(1.05);
                    }
                    .controlBar button {
                        transition: all 0.2s ease;
                    }
                    .controlBar button:hover {
                        transform: translateY(-1px);
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    }
                `;

                GM_addStyle(notificationCSS + `#toolbar{position:fixed;top:5vh;right:2vw;width:35px!important;min-width:35px!important;max-width:35px!important;background-color:#082849;border:2px solid #104437;padding:5px;z-index:9999;box-shadow:0 4px 8px rgba(0,0,0,0.2);font-family:sans-serif;color:#fff;user-select:none;overflow:hidden;}#toolbarHandle{height:20px;background-color:#104437;cursor:move;margin-bottom:5px;border-radius:3px;}#toolbarBottomHandle{height:20px;background-color:#104437;cursor:move;margin-top:5px;border-radius:3px;}#toolbar button,#toolbar select,#toolbar input[type="checkbox"]{display:block;width:100%!important;min-width:25px!important;margin:5px 0;padding:5px;font-size:12px;background-color:#104437;color:#fff;border:none;cursor:pointer;border-radius:5px;}#toolbar textarea{display:block;width:100%!important;min-width:25px!important;margin:5px 0;padding:5px;font-size:12px;background-color:#104437;color:#fff;border:none;border-radius:5px;height:25px!important;min-height:25px!important;max-height:25px!important;resize:none!important;overflow:hidden!important;line-height:15px!important;box-sizing:border-box!important;}#selectImageButton.active,#selectVideoThumbnailButton.active,#extractTagsButton.active{background-color:#3c9d6f;}#toolbar button:hover{background-color:#16a085;}#compressionButtons button.selected{background-color:#e67e22;}#pasteImageArea{height:25px!important;min-height:25px!important;max-height:25px!important;border:1px solid #16a085;resize:none!important;overflow:hidden!important;line-height:15px!important;box-sizing:border-box!important;}#compressedImage{max-width:100%;margin:5px 0;}#compressionRate{font-size:12px;margin:5px 0;}#debugOutput{display:none;}.window{position:fixed;width:950px;height:550px;background-color:#082849;border:2px solid #104437;padding:5px;z-index:10000;box-shadow:0 4px 8px rgba(0,0,0,0.2);font-family:sans-serif;color:#fff;user-select:none;overflow:hidden;}.toolbarHandle{height:20px;background-color:#104437;cursor:move;margin-bottom:5px;}.menuBar{display:flex;justify-content:space-between;padding:2px;background-color:#104437;height:20px;align-items:center;}.window .menuBar h3{margin:0;flex-grow:1;text-align:center;font-size:14px;}.left-buttons,.right-buttons{display:flex;gap:2px;}.window .menuBar button{padding:1px 3px;background-color:#082849;color:#fff;border:none;cursor:pointer;border-radius:3px;font-size:12px;}.minimizeButton,.maximizeButton{background-color:#104437!important;width:32px;height:32px;font-size:32px;padding:0;line-height:32px;}.window .menuBar button:hover{background-color:#16a085;}.debug-info{font-size:12px;white-space:nowrap;margin-left:5px;}.tabSidebar{position:absolute;left:0;top:110px;bottom:5px;width:110px!important;display:flex;flex-direction:column;gap:5px;padding:5px;overflow-y:auto;}.tab-vertical{width:100%;padding:5px;border:none;color:#fff;cursor:pointer;text-align:center;background-color:#104437;border-radius:5px;}.tab-vertical.active{background:#16a085;box-shadow:0 0 5px 4px rgba(255,255,255,0.7);transform:scale(1.2);z-index:1;}.tab-vertical img{width:24px;height:24px;}.tab-vertical span{font-family:sans-serif;font-size:16px;font-weight:bold;}.domain-text{font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:bold;}.tab-favicon{width:16px;height:16px;margin-left:4px;vertical-align:middle;}.controlBar{padding:5px;display:flex;gap:5px;flex-wrap:wrap;justify-content:flex-start;margin-left:110px;margin-top:25px;}.controlBar button,.controlBar select{padding:5px;background:#104437;color:#fff;border:none;font-size:12px;}.controlBar button:hover{background-color:#16a085;}.savedItems{margin-left:110px;margin-top:0;max-height:calc(100% - 80px);overflow-y:auto;padding:5px;display:flex;flex-wrap:wrap;gap:10px;}.savedItems.column{flex-direction:column;flex-wrap:nowrap;}.savedItem{padding:5px;background:#104437;border-radius:5px;position:relative;cursor:pointer;text-decoration:none;color:#fff;}.savedItem.column{flex:1 0 100%;}.savedItem.size-large{flex:0 0 400px;}.savedItem.size-standard{flex:0 0 300px;}.savedItem.size-medium{flex:0 0 280px;}.savedItem.size-small{flex:0 0 260px;}.savedItem.size-half{flex:0 0 250px;}.savedItem.size-third{flex:0 0 220px;}.savedItem.size-quarter{flex:0 0 200px;}.savedItem.size-mini{flex:0 0 180px;}.savedItem.selected{border:2px solid #16a085;}.savedItem img{width:100%;height:auto;object-fit:contain;}.savedItem p{margin:2px 0;font-size:12px;}.savedItem.image-only p{display:none;}.savedItem.image-title p:not(:nth-child(2)){display:none;}.savedItem.image-title p:nth-child(2){display:block;font-size:14px!important;font-weight:bold!important;}.savedItem a{color:#fff;}.selectItem{position:absolute;top:5px;left:5px;width:20px;height:20px;z-index:1;display:none;}.editing .selectItem{display:block;}.subMenu{position:absolute;background-color:#082849;border:1px solid #104437;box-shadow:0 2px 5px rgba(0,0,0,0.2);min-width:100px;z-index:10001;margin-top:30px;}.subMenuItem{padding:2px 5px;cursor:pointer;background-color:#082849!important;white-space:nowrap;font-size:14px;color:#fff;}.subMenuItem:hover{background-color:#16a085!important;color:#fff!important;}#logWindow{position:fixed;width:200px;height:150px;background:#082849;border:2px solid #104437;padding:5px;z-index:10002;box-shadow:0 4px 8px rgba(0,0,0,0.2);font-family:sans-serif;color:#fff;user-select:none;overflow:hidden;}#logWindow .menuBar{display:flex;justify-content:space-between;padding:2px;background-color:#104437;cursor:move;height:20px;align-items:center;}#logWindow .menuBar h3{margin:0;flex-grow:1;text-align:center;font-size:12px;}#logWindow .menuBar button{padding:1px 3px;background-color:#082849;color:#fff;border:none;cursor:pointer;border-radius:3px;font-size:12px;}#logWindow .menuBar button:hover{background-color:#16a085;}#logContent{max-height:calc(100% - 25px);overflow-y:auto;background:#333;padding:5px;font-size:10px;color:#fff;}.tabMenuPopup,.moveTabPopup,.tagEditPopup{position:fixed;background-color:#082849;border:2px solid #104437;padding:5px;z-index:10001;box-shadow:0 4px 8px rgba(0,0,0,0.2);font-family:sans-serif;color:#fff;width:300px;height:400px;left:50%;top:50%;transform:translate(-50%,-50%);overflow-y:auto;}.tabMenuPopup .menuBar,.moveTabPopup .menuBar,.tagEditPopup .menuBar{display:flex;justify-content:space-between;padding:2px;background-color:#104437;height:20px;align-items:center;}.tabMenuPopup .menuBar h3,.moveTabPopup .menuBar h3,.tagEditPopup .menuBar h3{margin:0;flex-grow:1;text-align:center;font-size:14px;}.tabMenuPopup .menuBar button,.moveTabPopup .menuBar button,.tagEditPopup .menuBar button{padding:1px 3px;background-color:#082849;color:#fff;border:none;cursor:pointer;border-radius:3px;font-size:12px;}.tabMenuPopup .menuBar button:hover,.moveTabPopup .menuBar button:hover,.tagEditPopup .menuBar button:hover{background-color:#16a085;}.moveTabContent,.tagEditContent{overflow-y:auto;padding:5px;}.tagFilterArea{transition:all 0.3s ease;}.tagFilterBtn:hover{transform:scale(1.05)!important;box-shadow:0 4px 8px rgba(0,0,0,0.3)!important;}.resize-handle{position:absolute;background:transparent;}.resize-top{top:-5px;left:0;width:100%;height:10px;cursor:ns-resize;}.resize-bottom{bottom:-5px;left:0;width:100%;height:10px;cursor:ns-resize;}.resize-left{left:-5px;top:0;width:10px;height:100%;cursor:ew-resize;}.resize-right{right:-5px;top:0;width:10px;height:100%;cursor:ew-resize;}`);
            };

            init();
        })();
