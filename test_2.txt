// ==UserScript==
// @name         ash8-nordjs
// @namespace    http://tampermonkey.net/
// @version      8.0.0-nordjs
// @description  webclip with nordjs storage and external css
// @match        *://*/*
// @grant        none
// ==/UserScript==

(async function() {
    'use strict';

    const NORDJS_API = 'http://127.0.0.1:17001/api';
    async function getValue(key, def) {
        try {
            const res = await fetch(`${NORDJS_API}/get`);
            const all = await res.json();
            if (!key) return all;
            if (typeof all === "object" && all !== null && key in all) return all[key];
            return def;
        } catch (e) { return def; }
    }
    async function setValue(key, value) {
        let all = {};
        try {
            const res = await fetch(`${NORDJS_API}/get`);
            all = await res.json();
        } catch {}
        if (typeof all !== "object" || all === null) all = {};
        all[key] = value;
        await fetch(`${NORDJS_API}/set`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(all)
        });
    }

    (function loadExternalCss() {
        const cssUrl = "http://127.0.0.1:17001/public/style.css";
        fetch(cssUrl)
            .then(r => r.text())
            .then(css => {
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
            });
    })();

    const logMessage = (message) => console.log(`${new Date().toLocaleTimeString()} - ${message}`);

    const StateManager = {
        window: null,
        customTabs: new Set(await getValue('customTabs', ['メモ'])),
        tabColors: new Map(Object.entries(await getValue('tabColors', {}))),
        tabThumbnails: new Map(Object.entries(await getValue('tabThumbnails', {}))),
        selectionMode: false,
        videoThumbnailMode: false,
        tagExtractionMode: false,
        compressionRate: 0.2,
        currentCompressedImage: null,
        isDraggingToolbar: false,
        offsetXToolbar: 0,
        offsetYToolbar: 0,
        zIndexCounter: 10000,
        activeMenu: null,
        activePopup: null,
        isHoverEnabled: false,
        async setWindow(windowObj) {
            this.window = windowObj;
            await setValue('savedWindow', windowObj ? windowObj.id : null);
        },
        async updateCustomTabs(tabs) {
            this.customTabs = new Set(tabs);
            await setValue('customTabs', [...this.customTabs]);
        },
        async setTabColor(tab, color) {
            this.tabColors.set(tab, color);
            await setValue('tabColors', Object.fromEntries(this.tabColors));
        },
        async setTabThumbnail(tab, thumbnail) {
            this.tabThumbnails.set(tab, thumbnail);
            await setValue('tabThumbnails', Object.fromEntries(this.tabThumbnails));
        }
    };

    const state = new Proxy(StateManager, {
        set(target, prop, value) {
            Reflect.set(target, prop, value);
            if (prop === 'currentCompressedImage' && value) {
                const img = document.getElementById('compressedImage');
                if (img) img.src = value;
                if (document.getElementById('autoSaveCheckbox')?.checked) saveImage();
            }
            if (prop === 'window' && value) updateTabs(value);
            return true;
        }
    });

    const EventManager = {
        handlers: new WeakMap(),
        add(element, type, handler, options = {}) {
            if (!element) return;
            element.addEventListener(type, handler, options);
            const handlers = this.handlers.get(element) || [];
            handlers.push({ type, handler, options });
            this.handlers.set(element, handlers);
        },
        removeAll(element) {
            const handlers = this.handlers.get(element) || [];
            handlers.forEach(({ type, handler, options }) => element.removeEventListener(type, handler, options));
            this.handlers.delete(element);
        }
    };
    const events = EventManager;

    const Toolbar = {
        elements: null,
        init() {
            try {
                const toolbar = document.createElement('div');
                toolbar.id = 'toolbar';
                const fragment = document.createDocumentFragment();

                const handle = document.createElement('div'); handle.id = 'toolbarHandle';
                const selectImgBtn = document.createElement('button'); selectImgBtn.id = 'selectImageButton'; selectImgBtn.textContent = '📸';
                const selectVidBtn = document.createElement('button'); selectVidBtn.id = 'selectVideoThumbnailButton'; selectVidBtn.textContent = '📹';
                const extractTagsBtn = document.createElement('button'); extractTagsBtn.id = 'extractTagsButton'; extractTagsBtn.textContent = '📌';
                const pasteArea = document.createElement('textarea'); pasteArea.id = 'pasteImageArea'; pasteArea.placeholder = 'copy';
                const compressionDiv = document.createElement('div'); compressionDiv.id = 'compressionButtons';
                const comp30 = document.createElement('button'); comp30.id = 'compression30'; comp30.textContent = '30';
                const comp50 = document.createElement('button'); comp50.id = 'compression50'; comp50.textContent = '50';
                const comp70 = document.createElement('button'); comp70.id = 'compression70'; comp70.textContent = '70';
                compressionDiv.append(comp30, comp50, comp70);
                const saveBtn = document.createElement('button'); saveBtn.id = 'saveButton'; saveBtn.textContent = '💾';
                const autoSave = document.createElement('input'); autoSave.type = 'checkbox'; autoSave.id = 'autoSaveCheckbox'; autoSave.checked = true; autoSave.title = '自動保存';
                const toggleWinBtn = document.createElement('button'); toggleWinBtn.id = 'toggleWindowButton'; toggleWinBtn.textContent = '🖼️';
                const logBtn = document.createElement('button'); logBtn.id = 'logButton'; logBtn.textContent = 'log';
                const exportBtn = document.createElement('button'); exportBtn.id = 'exportButton'; exportBtn.textContent = '📤';
                const importBtn = document.createElement('button'); importBtn.id = 'importButton'; importBtn.textContent = '📥';
                const compRate = document.createElement('div'); compRate.id = 'compressionRate';
                const debugOut = document.createElement('div'); debugOut.id = 'debugOutput';

                fragment.append(handle, selectImgBtn, selectVidBtn, extractTagsBtn, pasteArea, compressionDiv, saveBtn, autoSave, toggleWinBtn, logBtn, exportBtn, importBtn, compRate, debugOut);
                toolbar.appendChild(fragment);
                document.body.appendChild(toolbar);

                this.elements = {
                    toolbar,
                    selectImageButton: toolbar.querySelector('#selectImageButton'),
                    selectVideoThumbnailButton: toolbar.querySelector('#selectVideoThumbnailButton'),
                    extractTagsButton: toolbar.querySelector('#extractTagsButton'),
                    pasteImageArea: toolbar.querySelector('#pasteImageArea'),
                    compressionRateDisplay: toolbar.querySelector('#compressionRate'),
                    debugOutput: toolbar.querySelector('#debugOutput'),
                    saveButton: toolbar.querySelector('#saveButton'),
                    autoSaveCheckbox: toolbar.querySelector('#autoSaveCheckbox'),
                    toggleWindowButton: toolbar.querySelector('#toggleWindowButton'),
                    logButton: toolbar.querySelector('#logButton'),
                    exportButton: toolbar.querySelector('#exportButton'),
                    importButton: toolbar.querySelector('#importButton'),
                    toolbarHandle: toolbar.querySelector('#toolbarHandle'),
                    compression30: toolbar.querySelector('#compression30'),
                    compression50: toolbar.querySelector('#compression50'),
                    compression70: toolbar.querySelector('#compression70')
                };

                logMessage("ツールバー追加成功");
                this.setupEventListeners();
                return this.elements;
            } catch (e) {
                logMessage(`ツールバー初期化失敗: ${e.message}`);
                return null;
            }
        },
        setupEventListeners() {
            events.add(window, 'load', () => this.elements.autoSaveCheckbox.checked = true);
            events.add(this.elements.selectImageButton, 'click', () => this.startImageSelectionMode());
            events.add(this.elements.selectVideoThumbnailButton, 'click', () => this.startVideoThumbnailMode());
            events.add(this.elements.extractTagsButton, 'click', () => this.startTagExtractionMode());
            events.add(this.elements.paste3221ImageArea, 'contextmenu', (e) => this.pasteImageFromClipboard(e));
            events.add(this.elements.saveButton, 'click', () => saveImage());
            events.add(this.elements.toggleWindowButton, 'click', () => this.toggleWindow());
            events.add(this.elements.logButton, 'click', () => createLogWindow());
            events.add(this.elements.exportButton, 'click', () => this.exportItems());
            events.add(this.elements.importButton, 'click', () => this.importItems());
            events.add(this.elements.compression30, 'click', () => this.setCompressionRate(0.3));
            events.add(this.elements.compression50, 'click', () => this.setCompressionRate(0.5));
            events.add(this.elements.compression70, 'click', () => this.setCompressionRate(0.7));
            this.setupDrag();
            logMessage("ツールバーリスナー設定完了");
        },
        startImageSelectionMode() {
            if (state.videoThumbnailMode) {
                state.videoThumbnailMode = false;
                this.elements.selectVideoThumbnailButton.textContent = "📹";
                this.elements.selectVideoThumbnailButton.classList.remove("active");
                events.removeAll(document);
            }
            state.selectionMode = true;
            this.elements.selectImageButton.textContent = "ON";
            this.elements.selectImageButton.classList.add("active");
            events.add(document, 'click', (e) => this.handleImageClick(e), { capture: true });
            logMessage("画像選択モード開始");
        },
        handleImageClick(event) {
            if (!state.selectionMode || event.target.tagName.toLowerCase() !== 'img') return;
            event.preventDefault();
            event.stopPropagation();
            state.selectionMode = false;
            this.elements.selectImageButton.textContent = "📸";
            this.elements.selectImageButton.classList.remove("active");
            events.removeAll(document);
            const src = new URL(event.target.src, location.href).href;
            logMessage(`画像選択: ${src}`);
            this.processImage(src);
        },
        startVideoThumbnailMode() {
            if (state.selectionMode) {
                state.selectionMode = false;
                this.elements.selectImageButton.textContent = "📸";
                this.elements.selectImageButton.classList.remove("active");
                events.removeAll(document);
            }
            state.videoThumbnailMode = true;
            this.elements.selectVideoThumbnailButton.textContent = "動画をクリック";
            this.elements.selectVideoThumbnailButton.classList.add("active");
            events.add(document, 'click', (e) => this.handleVideoThumbnailClick(e), { capture: true });
        },
        handleVideoThumbnailClick(event) {
            if (!state.videoThumbnailMode || event.target.tagName.toLowerCase() !== 'video') return;
            event.preventDefault();
            event.stopPropagation();
            state.videoThumbnailMode = false;
            this.elements.selectVideoThumbnailButton.textContent = "📹";
            this.elements.selectVideoThumbnailButton.classList.remove("active");
            events.removeAll(document);
            const video = event.target;
            logMessage(`動画選択: ${video.src}`);
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const thumbnailDataURL = canvas.toDataURL('image/jpeg');
            logMessage(`サムネイルキャプチャ完了: ${canvas.width}x${canvas.height}`);
            this.processImage(thumbnailDataURL);
        },
        async startTagExtractionMode() {
            state.tagExtractionMode = true;
            this.elements.extractTagsButton.textContent = "タグ抽出中";
            this.elements.extractTagsButton.classList.add("active");
            const { tags, extractedDate } = extractTagsAndDate();
            if (tags.length || extractedDate) {
                const domain = window.location.hostname;
                const savedData = {
                    image: state.currentCompressedImage || '',
                    url: window.location.href,
                    title: document.title,
                    favicon: getFaviconForNewTab(domain, window.location.href),
                    timestamp: new Date().toISOString(),
                    tab: domain,
                    tags,
                    extractedDate
                };
                const allItems = await getValue('savedItems', []);
                allItems.push(savedData);
                await setValue('savedItems', allItems);
                if (state.window) {
                    state.window.activeTab = domain;
                    updateTabs(state.window);
                }
                logMessage('タグと日付保存成功');
            }
            state.tagExtractionMode = false;
            this.elements.extractTagsButton.textContent = "📌";
            this.elements.extractTagsButton.classList.remove("active");
        },
        setCompressionRate(rate) {
            state.compressionRate = rate;
            document.querySelectorAll('#compressionButtons button').forEach(b => b.classList.remove('selected'));
            document.getElementById(`compression${rate * 100}`).classList.add('selected');
            this.startImageSelectionMode();
        },
        pasteImageFromClipboard(event) {
            event.preventDefault();
            logMessage('クリップボードから画像貼り付け開始');
            navigator.clipboard.read().then(data => {
                if (!data.some(item => item.types.some(type => type.startsWith('image/')))) {
                    logMessage('クリップボードに画像なし');
                    return;
                }
                for (const item of data) {
                    for (const type of item.types) {
                        if (type.startsWith('image/')) {
                            item.getType(type).then(blob => {
                                const reader = new FileReader();
                                reader.onload = (e) => this.processImage(e.target.result);
                                reader.readAsDataURL(blob);
                            }).catch(err => logMessage(`クリップボード画像取得失敗: ${err.message}`));
                            break;
                        }
                    }
                }
            }).catch(err => logMessage(`クリップボード読み込み失敗: ${err.message}`));
        },
        processImage(src) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = src;
            img.onload = () => {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = Math.floor(img.width * state.compressionRate);
                    canvas.height = Math.floor(img.height * state.compressionRate);
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const compressedDataURL = canvas.toDataURL('image/jpeg', state.compressionRate);
                    state.currentCompressedImage = compressedDataURL;
                    const originalDataURL = canvas.toDataURL('image/jpeg', 1.0);
                    const rate = ((1 - compressedDataURL.length / originalDataURL.length) * 100).toFixed(2);
                    this.elements.compressionRateDisplay.textContent = `圧縮率: ${rate}%`;
                    logMessage(`画像圧縮成功: ${rate}%`);
                } catch (e) {
                    logMessage(`画像圧縮失敗: ${e.message}`);
                    this.elements.compressionRateDisplay.textContent = "圧縮失敗";
                }
            };
            img.onerror = () => {
                logMessage(`画像読み込み失敗: ${src} (CORSの可能性)`);
                this.elements.compressionRateDisplay.textContent = "画像読み込み失敗";
            };
        },
        async exportItems() {
            try {
                const allItems = await getValue('savedItems', []);
                const customTabs = [...state.customTabs];
                const tabColors = Object.fromEntries(state.tabColors);
                const tabThumbnails = Object.fromEntries(state.tabThumbnails);
                const exportData = { items: allItems, customTabs, tabColors, tabThumbnails };
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `saved_items_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                logMessage('アイテムのエクスポート成功');
                alert('エクスポートが完了しました。');
            } catch (e) {
                logMessage(`エクスポート失敗: ${e.message}`);
                alert('エクスポートに失敗しました。');
            }
        },
        async importItems() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (!data.items || !Array.isArray(data.items)) throw new Error('無効なJSON形式');
                        const confirmMerge = confirm('既存のデータを保持してマージしますか？（いいえを選択すると上書きされます）');
                        let allItems = confirmMerge ? await getValue('savedItems', []) : [];
                        allItems = [...allItems, ...data.items];
                        await setValue('savedItems', allItems);
                        if (data.customTabs && Array.isArray(data.customTabs)) {
                            await state.updateCustomTabs([...new Set([...state.customTabs, ...data.customTabs])]);
                        }
                        if (data.tabColors && typeof data.tabColors === 'object') {
                            Object.entries(data.tabColors).forEach(([tab, color]) => state.setTabColor(tab, color));
                        }
                        if (data.tabThumbnails && typeof data.tabThumbnails === 'object') {
                            Object.entries(data.tabThumbnails).forEach(([tab, thumbnail]) => state.setTabThumbnail(tab, thumbnail));
                        }
                        if (state.window) {
                            updateTabs(state.window);
                            displaySavedItems(state.window);
                        }
                        logMessage('アイテムのインポート成功');
                        alert('インポートが完了しました。');
                    } catch (err) {
                        logMessage(`インポート失敗: ${err.message}`);
                        alert('インポートの処理に失敗しました。ファイルを確認してください。');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        },
        async setupDrag() {
            const handleMove = (e) => {
                if (state.isDraggingToolbar) {
                    let leftPx = e.clientX - state.offsetXToolbar;
                    let topPx = e.clientY - state.offsetYToolbar;
                    leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - this.elements.toolbar.offsetWidth));
                    topPx = Math.max(0, Math.min(topPx, window.innerHeight - this.elements.toolbar.offsetHeight));
                    requestAnimationFrame(() => {
                        this.elements.toolbar.style.left = `${leftPx}px`;
                        this.elements.toolbar.style.top = `${topPx}px`;
                    });
                }
            };
            const handleUp = async () => {
                if (state.isDraggingToolbar) {
                    await setValue('toolbarPosition', { left: this.elements.toolbar.style.left, top: this.elements.toolbar.style.top });
                    state.isDraggingToolbar = false;
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('mouseup', handleUp);
                }
            };
            events.add(this.elements.toolbarHandle, 'mousedown', (e) => {
                state.isDraggingToolbar = true;
                state.offsetXToolbar = e.clientX - this.elements.toolbar.offsetLeft;
                state.offsetYToolbar = e.clientY - this.elements.toolbar.offsetTop;
                e.preventDefault();
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleUp);
            });
        },
        toggleWindow() {
            if (!state.window) {
                const id = 'single-window';
                const savedState = await getValue(`windowState-${id}`, { position: { left: '21px', top: '23px' }, size: { width: '950px', height: '550px' } });
                const windowObj = Window.create(id, savedState);
                if (windowObj) state.setWindow(windowObj);
                windowObj.el.style.display = 'none';
            }
            const windowEl = state.window.el;
            windowEl.style.display = windowEl.style.display === 'none' ? 'block' : 'none';
            if (windowEl.style.display === 'block') bringToFront(state.window);
            Window.saveState(state.window);
            this.elements.toggleWindowButton.textContent = windowEl.style.display === 'block' ? '🔽' : '🖼️';
        }
    };

    const Window = {
        colorPresets: new Map([['赤', '#8B0000'], ['青', '#1E90FF'], ['黄色', '#DAA520'], ['緑', '#228B22'], ['ピンク', '#C71585'], ['オレンジ', '#FF4500'], ['紫', '#4B0082'], ['茶色', '#8B4513'], ['灰色', '#696969']]),
        thumbnailPresets: ['🌟', '📌', '📷', '📖', '🎵'],
        create(id, savedState) {
            try {
                const el = document.createElement('div');
                el.className = 'window';
                el.id = `window-${id}`;
                const fragment = document.createDocumentFragment();

                const windowObj = {
                    el,
                    id,
                    name: savedState?.name || '1',
                    activeTab: savedState?.activeTab || [...state.customTabs][0],
                    isMaximized: savedState?.isMaximized || false,
                    sortOrder: savedState?.sortOrder || 'newest',
                    layout: savedState?.layout || 'tile',
                    itemSize: savedState?.itemSize || 'standard',
                    displayMode: savedState?.displayMode || 'full',
                    position: savedState?.position || { left: '21px', top: '23px' },
                    size: savedState?.size || { width: '950px', height: '550px' },
                    isEditing: false
                };

                const toolbarHandle = document.createElement('div'); toolbarHandle.className = 'toolbarHandle';
                const menuBar = document.createElement('div'); menuBar.className = 'menuBar';
                const leftButtons = document.createElement('div'); leftButtons.className = 'left-buttons';
                const tabMenuBtn = document.createElement('button'); tabMenuBtn.className = 'tabMenuButton'; tabMenuBtn.textContent = 'タブ';
                const windowMenuBtn = document.createElement('button'); windowMenuBtn.className = 'windowMenuButton'; windowMenuBtn.textContent = 'ウィンドウ';
                const itemMenuBtn = document.createElement('button'); itemMenuBtn.className = 'itemMenuButton'; itemMenuBtn.textContent = 'アイテム';
                leftButtons.append(tabMenuBtn, windowMenuBtn, itemMenuBtn);
                const title = document.createElement('h3'); title.textContent = windowObj.name;
                const rightButtons = document.createElement('div'); rightButtons.className = 'right-buttons';
                const debugInfo = document.createElement('span'); debugInfo.className = 'debug-info';
                const minimizeBtn = document.createElement('button'); minimizeBtn.className = 'minimizeButton'; minimizeBtn.textContent = '─';
                const maximizeBtn = document.createElement('button'); maximizeBtn.className = 'maximizeButton'; maximizeBtn.textContent = '□';
                rightButtons.append(debugInfo, minimizeBtn, maximizeBtn);
                menuBar.append(leftButtons, title, rightButtons);

                const controlBar = document.createElement('div'); controlBar.className = 'controlBar';
                const editBtn = document.createElement('button'); editBtn.className = 'editButton'; editBtn.textContent = '編集';
                const layoutBtn = document.createElement('button'); layoutBtn.className = 'layoutButton'; layoutBtn.textContent = 'タイル';
                const sortSelect = document.createElement('select'); sortSelect.className = 'sortSelect';
                ['newest:新しい順', 'oldest:古い順', 'extractedDateOldest:抽出日付 古い順', 'extractedDateNewest:抽出日付 新しい順'].forEach(opt => {
                    const option = document.createElement('option');
                    const [value, text] = opt.split(':');
                    option.value = value;
                    option.textContent = text;
                    sortSelect.appendChild(option);
                });
                const itemSizeSelect = document.createElement('select'); itemSizeSelect.className = 'itemSizeSelect';
                ['standard:標準', 'half:1/2', 'quarter:1/4'].forEach(opt => {
                    const option = document.createElement('option');
                    const [value, text] = opt.split(':');
                    option.value = value;
                    option.textContent = text;
                    itemSizeSelect.appendChild(option);
                });
                const displayModeSelect = document.createElement('select'); displayModeSelect.className = 'displayModeSelect';
                ['full:すべて表示', 'image-only:画像のみ', 'image-title:画像とタイトル'].forEach(opt => {
                    const option = document.createElement('option');
                    const [value, text] = opt.split(':');
                    option.value = value;
                    option.textContent = text;
                    displayModeSelect.appendChild(option);
                });
                controlBar.append(editBtn, layoutBtn, sortSelect, itemSizeSelect, displayModeSelect);

                const tabSidebar = document.createElement('div'); tabSidebar.className = 'tabSidebar';
                const savedItems = document.createElement('div'); savedItems.className = 'savedItems';
                const resizeTop = document.createElement('div'); resizeTop.className = 'resize-handle resize-top';
                const resizeBottom = document.createElement('div'); resizeBottom.className = 'resize-handle resize-bottom';
                const resizeLeft = document.createElement('div'); resizeLeft.className = 'resize-handle resize-left';
                const resizeRight = document.createElement('div'); resizeRight.className = 'resize-handle resize-right';

                fragment.append(toolbarHandle, menuBar, controlBar, tabSidebar, savedItems, resizeTop, resizeBottom, resizeLeft, resizeRight);
                el.appendChild(fragment);
                document.body.appendChild(el);

                logMessage(`ウィンドウ ${id} 追加成功`);
                this.setupEventListeners(windowObj);
                updateTabs(windowObj);
                displaySavedItems(windowObj);
                el.style.left = windowObj.position.left;
                el.style.top = windowObj.position.top;
                el.style.width = windowObj.size.width;
                el.style.height = windowObj.size.height;
                el.style.display = 'none';
                return windowObj;
            } catch (e) {
                logMessage(`ウィンドウ ${id} 作成失敗: ${e.message}`);
                return null;
            }
        },
        async setupEventListeners(windowObj) {
            const toolbarHandle = windowObj.el.querySelector('.toolbarHandle'),
                  minimizeButton = windowObj.el.querySelector('.minimizeButton'),
                  maximizeButton = windowObj.el.querySelector('.maximizeButton'),
                  tabMenuButton = windowObj.el.querySelector('.tabMenuButton'),
                  windowMenuButton = windowObj.el.querySelector('.windowMenuButton'),
                  itemMenuButton = windowObj.el.querySelector('.itemMenuButton'),
                  menuBar = windowObj.el.querySelector('.menuBar'),
                  editButton = windowObj.el.querySelector('.editButton'),
                  layoutButton = windowObj.el.querySelector('.layoutButton'),
                  sortSelect = windowObj.el.querySelector('.sortSelect'),
                  itemSizeSelect = windowObj.el.querySelector('.itemSizeSelect'),
                  displayModeSelect = windowObj.el.querySelector('.displayModeSelect'),
                  savedItems = windowObj.el.querySelector('.savedItems'),
                  controlBar = windowObj.el.querySelector('.controlBar'),
                  debugInfo = windowObj.el.querySelector('.debug-info');
            sortSelect.value = windowObj.sortOrder;
            events.add(sortSelect, 'change', async () => {
                windowObj.sortOrder = sortSelect.value;
                await setValue(`sortOrder-${windowObj.id}`, windowObj.sortOrder);
                displaySavedItems(windowObj);
                this.saveState(windowObj);
            });
            itemSizeSelect.value = windowObj.itemSize;
            events.add(itemSizeSelect, 'change', async () => {
                windowObj.itemSize = itemSizeSelect.value;
                await setValue(`itemSize-${windowObj.id}`, windowObj.itemSize);
                displaySavedItems(windowObj);
                this.saveState(windowObj);
            });
            displayModeSelect.value = windowObj.displayMode;
            events.add(displayModeSelect, 'change', async () => {
                windowObj.displayMode = displayModeSelect.value;
                await setValue(`displayMode-${windowObj.id}`, windowObj.displayMode);
                displaySavedItems(windowObj);
                this.saveState(windowObj);
            });
            events.add(windowObj.el, 'mousedown', () => {
                bringToFront(windowObj);
                if (state.activeMenu && !menuBar.contains(event.target) && !state.activeMenu.contains(event.target)) {
                    closeActiveMenu();
                    state.isHoverEnabled = false;
                }
            });
            const updateDebugInfo = () => debugInfo.textContent = `(${windowObj.el.style.left}, ${windowObj.el.style.top}) ${windowObj.el.style.width}x${windowObj.el.style.height}`;
            updateDebugInfo();
            let isDragging = false, offsetX, offsetY;
            const handleDragMove = (e) => {
                if (isDragging) {
                    let leftPx = e.clientX - offsetX;
                    let topPx = e.clientY - offsetY;
                    let widthPx = parseInt(windowObj.el.style.width);
                    let heightPx = parseInt(windowObj.el.style.height);
                    leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - widthPx));
                    topPx = Math.max(0, Math.min(topPx, window.innerHeight - heightPx - 40));
                    requestAnimationFrame(() => {
                        windowObj.el.style.left = `${leftPx}px`;
                        windowObj.el.style.top = `${topPx}px`;
                    });
                }
            };
            const handleDragEnd = async () => {
                if (isDragging) {
                    await this.saveState(windowObj);
                    isDragging = false;
                    document.removeEventListener('mousemove', handleDragMove);
                    document.removeEventListener('mouseup', handleDragEnd);
                }
            };
            events.add(toolbarHandle, 'mousedown', (e) => {
                isDragging = true;
                offsetX = e.clientX - windowObj.el.offsetLeft;
                offsetY = e.clientY - windowObj.el.offsetTop;
                e.preventDefault();
                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd);
            });
            let isResizing = false, resizeDir, startX, startY, startWidth, startHeight, startLeft, startTop;
            const handleResizeMove = (e) => {
                if (!isResizing) return;
                let deltaX = e.clientX - startX;
                let deltaY = e.clientY - startY;
                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;
                if (resizeDir === 'top') {
                    newHeight = startHeight - deltaY;
                    newTop = startTop + deltaY;
                } else if (resizeDir === 'bottom') {
                    newHeight = startHeight + deltaY;
                } else if (resizeDir === 'left') {
                    newWidth = startWidth - deltaX;
                    newLeft = startLeft + deltaX;
                } else if (resizeDir === 'right') {
                    newWidth = startWidth + deltaX;
                }
                newWidth = Math.max(200, Math.min(newWidth, window.innerWidth - newLeft));
                newHeight = Math.max(150, Math.min(newHeight, window.innerHeight - newTop - 40));
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - newWidth));
                newTop = Math.max(0, Math.min(newTop, window.innerHeight - newHeight - 40));
                requestAnimationFrame(() => {
                    windowObj.el.style.width = `${newWidth}px`;
                    windowObj.el.style.height = `${newHeight}px`;
                    windowObj.el.style.left = `${newLeft}px`;
                    windowObj.el.style.top = `${newTop}px`;
                });
            };
            const handleResizeEnd = async () => {
                if (isResizing) {
                    await this.saveState(windowObj);
                    isResizing = false;
                    document.removeEventListener('mousemove', handleResizeMove);
                    document.removeEventListener('mouseup', handleResizeEnd);
                }
            };
            ['top', 'bottom', 'left', 'right'].forEach(dir => {
                const handle = windowObj.el.querySelector(`.resize-${dir}`);
                events.add(handle, 'mousedown', (e) => {
                    isResizing = true;
                    resizeDir = dir;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(windowObj.el.style.width);
                    startHeight = parseInt(windowObj.el.style.height);
                    startLeft = parseFloat(windowObj.el.style.left);
                    startTop = parseFloat(windowObj.el.style.top);
                    e.preventDefault();
                    document.addEventListener('mousemove', handleResizeMove);
                    document.addEventListener('mouseup', handleResizeEnd);
                });
            });
            events.add(savedItems, 'wheel', (e) => {
                e.preventDefault();
                savedItems.scrollTop += e.deltaY;
            });
            events.add(minimizeButton, 'click', async () => {
                windowObj.el.style.display = 'none';
                await this.saveState(windowObj);
                Toolbar.elements.toggleWindowButton.textContent = '🖼️';
            });
            events.add(maximizeButton, 'click', async () => {
                if (!windowObj.isMaximized) {
                    windowObj.size = { width: windowObj.el.style.width, height: windowObj.el.style.height };
                    windowObj.el.style.width = `${window.innerWidth}px`;
                    windowObj.el.style.height = `${window.innerHeight - 40}px`;
                    windowObj.el.style.top = '0';
                    windowObj.el.style.left = '0';
                    maximizeButton.textContent = '🗗';
                } else {
                    windowObj.el.style.width = windowObj.size.width;
                    windowObj.el.style.height = windowObj.size.height;
                    windowObj.el.style.top = windowObj.position.top;
                    windowObj.el.style.left = windowObj.position.left;
                    maximizeButton.textContent = '□';
                }
                windowObj.isMaximized = !windowObj.isMaximized;
                await this.saveState(windowObj);
            });
            const menuButtons = [
                { button: tabMenuButton, type: 'tab' },
                { button: windowMenuButton, type: 'window' },
                { button: itemMenuButton, type: 'item' }
            ];
            menuButtons.forEach(menu => {
                events.add(menu.button, 'click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (state.isHoverEnabled) {
                        closeActiveMenu();
                        state.isHoverEnabled = false;
                        logMessage('ホバー状態を解除しました（メニューバー再クリック）');
                    } else {
                        closeActiveMenu();
                        state.isHoverEnabled = true;
                        state.activeMenu = this.createSubMenu(windowObj, menu.type, menu.button);
                        addCloseOnClickOutside(state.activeMenu, menuBar);
                        logMessage(`メニューを開きました: ${menu.type}`);
                    }
                });
                events.add(menu.button, 'mouseenter', () => {
                    if (state.isHoverEnabled && !state.activePopup) {
                        closeActiveMenu();
                        state.activeMenu = this.createSubMenu(windowObj, menu.type, menu.button);
                        addCloseOnClickOutside(state.activeMenu, menuBar);
                        logMessage(`ホバーでメニューを開きました: ${menu.type}`);
                    }
                });
            });
            events.add(editButton, 'click', () => {
                if (windowObj.isEditing) {
                    controlBar.querySelectorAll('.moveTabButton, .selectAll, .deselectAll, .deleteSelected').forEach(btn => btn.remove());
                    editButton.textContent = '編集';
                    windowObj.isEditing = false;
                    windowObj.el.classList.remove('editing');
                    savedItems.querySelectorAll('.savedItem').forEach(item => {
                        events.removeAll(item);
                        item.style.cursor = 'pointer';
                        item.classList.remove('selected');
                        const checkbox = item.querySelector('.selectItem');
                        if (checkbox) checkbox.checked = false;
                    });
                    logMessage(`編集モード終了: ${windowObj.id}`);
                } else {
                    const moveTabBtn = document.createElement('button');
                    moveTabBtn.className = 'moveTabButton';
                    moveTabBtn.textContent = '➡';
                    events.add(moveTabBtn, 'click', () => {
                        const checkboxes = savedItems.querySelectorAll('.selectItem:checked');
                        if (!checkboxes.length) return;
                        if (state.activePopup) {
                            state.activePopup.remove();
                            state.activePopup = null;
                        }
                        state.activePopup = createMoveTabWindow(windowObj, checkboxes);
                    });
                    const selectAllBtn = document.createElement('button');
                    selectAllBtn.className = 'selectAll';
                    selectAllBtn.textContent = '全選択';
                    events.add(selectAllBtn, 'click', () => {
                        savedItems.querySelectorAll('.selectItem').forEach(cb => {
                            cb.checked = true;
                            cb.parentElement.classList.add('selected');
                        });
                    });
                    const deselectAllBtn = document.createElement('button');
                    deselectAllBtn.className = 'deselectAll';
                    deselectAllBtn.textContent = '全解除';
                    events.add(deselectAllBtn, 'click', () => {
                        savedItems.querySelectorAll('.selectItem').forEach(cb => {
                            cb.checked = false;
                            cb.parentElement.classList.remove('selected');
                        });
                    });
                    const deleteSelectedBtn = document.createElement('button');
                    deleteSelectedBtn.className = 'deleteSelected';
                    deleteSelectedBtn.textContent = '🗑️';
                    events.add(deleteSelectedBtn, 'click', async () => {
                        const checkboxes = savedItems.querySelectorAll('.selectItem:checked');
                        if (!checkboxes.length) return;
                        let allItems = await getValue('savedItems', []);
                        checkboxes.forEach(cb => {
                            const timestamp = cb.parentElement.dataset.timestamp;
                            allItems = allItems.filter(item => item.timestamp !== timestamp);
                        });
                        await setValue('savedItems', allItems);
                        displaySavedItems(windowObj);
                    });
                    controlBar.insertBefore(moveTabBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(selectAllBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(deselectAllBtn, controlBar.querySelector('.layoutButton'));
                    controlBar.insertBefore(deleteSelectedBtn, controlBar.querySelector('.layoutButton'));
                    editButton.textContent = '終了';
                    windowObj.isEditing = true;
                    windowObj.el.classList.add('editing');
                    addItemClickListeners(windowObj, savedItems.querySelectorAll('.savedItem'));
                    logMessage(`編集モード開始: ${windowObj.id}`);
                }
            });
            events.add(layoutButton, 'click', async () => {
                windowObj.layout = windowObj.layout === 'tile' ? 'column' : 'tile';
                await setValue(`layout-${windowObj.id}`, windowObj.layout);
                layoutButton.textContent = windowObj.layout === 'tile' ? 'タイル' : '1列';
                displaySavedItems(windowObj);
                await this.saveState(windowObj);
            });
            layoutButton.textContent = windowObj.layout === 'tile' ? 'タイル' : '1列';
            logMessage(`ウィンドウ ${windowObj.id} リスナー設定完了`);
        },
        createSubMenu(windowObj, type, button) {
            const subMenu = document.createElement('div');
            subMenu.className = 'subMenu';
            const menuBar = button.closest('.menuBar');
            const menuBarRect = menuBar.getBoundingClientRect();
            const buttonRect = button.getBoundingClientRect();
            const windowRect = windowObj.el.getBoundingClientRect();
            subMenu.style.position = 'absolute';
            subMenu.style.left = `${buttonRect.left - windowRect.left}px`;
            subMenu.style.top = `${menuBarRect.height}px`;
            const fragment = document.createDocumentFragment();
            const items = type === 'tab' ? [{ text: 'タブ管理', action: () => createTabManageWindow(windowObj) }] : type === 'window' ? [] : [{
                text: 'すべてのアイテムを削除',
                action: async () => {
                    if (confirm('すべてのアイテムを削除しますか？')) {
                        await setValue('savedItems', []);
                        displaySavedItems(windowObj);
                    }
                }
            }];
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.text;
                menuItem.className = 'subMenuItem';
                events.add(menuItem, 'click', (e) => {
                    e.stopPropagation();
                    closeActiveMenu();
                    if (state.activePopup) {
                        state.activePopup.remove();
                        state.activePopup = null;
                    }
                    state.activePopup = item.action();
                    bringToFrontPopup(state.activePopup);
                });
                events.add(menuItem, 'mouseenter', () => menuItem.style.backgroundColor = '#ddd');
                events.add(menuItem, 'mouseleave', () => menuItem.style.backgroundColor = '#f0f0f0');
                fragment.appendChild(menuItem);
            });
            subMenu.appendChild(fragment);
            windowObj.el.appendChild(subMenu);
            return subMenu;
        },
        async saveState(windowObj) {
            const savedState = {
                name: windowObj.name,
                activeTab: windowObj.activeTab,
                isMaximized: windowObj.isMaximized,
                sortOrder: windowObj.sortOrder,
                layout: windowObj.layout,
                itemSize: windowObj.itemSize,
                displayMode: windowObj.displayMode,
                position: { left: windowObj.el.style.left, top: windowObj.el.style.top },
                size: { width: windowObj.el.style.width, height: windowObj.el.style.height },
                display: windowObj.el.style.display
            };
            await setValue(`windowState-${windowObj.id}`, savedState);
        }
    };

    const saveImage = async () => {
        if (!state.currentCompressedImage || !state.window) {
            logMessage('保存失敗: 画像なしまたはウィンドウなし');
            return;
        }
        const domain = window.location.hostname;
        const { tags, extractedDate } = extractTagsAndDate();
        const favicon = getFaviconForNewTab(domain, window.location.href);
        const savedData = {
            image: state.currentCompressedImage,
            url: window.location.href,
            title: document.title,
            favicon,
            timestamp: new Date().toISOString(),
            tab: domain,
            tags,
            extractedDate
        };
        const allItems = await getValue('savedItems', []);
        allItems.push(savedData);
        await setValue('savedItems', allItems);
        state.window.activeTab = domain;
        updateTabs(state.window);
        displaySavedItems(state.window);
        logMessage('画像とタグ、日付保存成功');
    };

    const extractTagsAndDate = () => {
        const tags = new Set();
        let extractedDate = null;
        document.querySelectorAll('div.q-chip').forEach(el => {
            const content = el.querySelector('.q-chip__content');
            if (content && content.textContent.trim()) {
                const tagText = content.textContent.trim();
                if (tagText.length > 0 && tagText.length < 20) tags.add(tagText);
            }
        });
        const dateElement = document.querySelector('div.absolute-bottom-right');
        if (dateElement && dateElement.textContent.trim()) extractedDate = dateElement.textContent.trim();
        const tagArray = [...tags];
        logMessage(`タグ抽出完了: ${tagArray.length}個 (${tagArray.join(', ')}), 日付: ${extractedDate || 'なし'}`);
        return { tags: tagArray, extractedDate };
    };

    const getFaviconForNewTab = async (tab, url) => {
        const allItems = await getValue('savedItems', []);
        const existingTab = allItems.find(item => item.tab === tab);
        if (existingTab) {
            logMessage(`既存タブ ${tab} のファビコンを再利用`);
            return existingTab.favicon;
        }
        const favicon = document.querySelector('link[rel="icon"]')?.href || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><circle cx="8" cy="8" r="7" fill="#104437"/></svg>';
        logMessage(`ファビコン取得: ${favicon}`);
        return favicon;
    };

    const updateTabs = async (windowObj) => {
        const tabSidebar = windowObj.el.querySelector('.tabSidebar');
        tabSidebar.innerHTML = '';
        const allItems = await getValue('savedItems', []);
        const autoTabs = new Set(allItems.map(item => item.tab).filter(t => !state.customTabs.has(t)));
        const allTabs = [...state.customTabs, ...autoTabs];
        const fragment = document.createDocumentFragment();
        allTabs.forEach(tab => {
            const tabButton = document.createElement('button');
            tabButton.className = 'tab-vertical';
            tabButton.dataset.tab = tab;
            const favicon = allItems.find(item => item.tab === tab)?.favicon;
            tabButton.innerHTML = favicon && !state.customTabs.has(tab) && !state.tabThumbnails.has(tab) ? `<img src="${favicon}">` : `<span>${state.tabThumbnails.get(tab) || tab[0]}</span>`;
            tabButton.style.backgroundColor = state.tabColors.get(tab) || '#104437';
            tabButton.title = tab;
            events.add(tabButton, 'click', async () => {
                windowObj.activeTab = tab;
                await setValue(`activeTab-${windowObj.id}`, tab);
                tabSidebar.querySelectorAll('.tab-vertical').forEach(t => t.classList.remove('active'));
                tabButton.classList.add('active');
                bringToFront(windowObj);
                displaySavedItems(windowObj);
                await Window.saveState(windowObj);
            });
            fragment.appendChild(tabButton);
            if (tab === windowObj.activeTab) tabButton.classList.add('active');
        });
        tabSidebar.appendChild(fragment);
    };

    const displaySavedItems = async (windowObj) => {
        const savedItems = (await getValue('savedItems', [])).filter(item => item.tab === windowObj.activeTab);
        let sortedItems = [...savedItems];
        if (windowObj.sortOrder === 'newest') sortedItems.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        else if (windowObj.sortOrder === 'oldest') sortedItems.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        else if (windowObj.sortOrder === 'extractedDateOldest') {
            const itemsWithDate = sortedItems.filter(item => item.extractedDate);
            const itemsWithoutDate = sortedItems.filter(item => !item.extractedDate);
            itemsWithDate.sort((a, b) => new Date(a.extractedDate) - new Date(b.extractedDate));
            sortedItems = [...itemsWithDate, ...itemsWithoutDate];
        } else if (windowObj.sortOrder === 'extractedDateNewest') {
            const itemsWithDate = sortedItems.filter(item => item.extractedDate);
            const itemsWithoutDate = sortedItems.filter(item => !item.extractedDate);
            itemsWithDate.sort((a, b) => new Date(b.extractedDate) - new Date(a.extractedDate));
            sortedItems = [...itemsWithDate, ...itemsWithoutDate];
        }
        const itemsDiv = windowObj.el.querySelector('.savedItems');
        itemsDiv.className = `savedItems ${windowObj.layout === 'column' ? 'column' : ''}`;
        itemsDiv.innerHTML = '';
        const fragment = document.createDocumentFragment();
        sortedItems.forEach(item => {
            const a = document.createElement('a');
            a.href = item.url;
            a.target = '_blank';
            a.className = `savedItem ${windowObj.layout === 'column' ? 'column' : ''} size-${windowObj.itemSize} ${windowObj.displayMode === 'image-only' ? 'image-only' : ''} ${windowObj.displayMode === 'image-title' ? 'image-title' : ''}`;
            a.dataset.timestamp = item.timestamp;
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'selectItem';
            a.appendChild(checkbox);
            const img = document.createElement('img');
            img.src = item.image;
            img.alt = '圧縮画像';
            a.appendChild(img);
            const titleP = document.createElement('p');
            const titleStrong = document.createElement('strong');
            titleStrong.textContent = ' ';
            titleP.appendChild(titleStrong);
            titleP.appendChild(document.createTextNode(item.title));
            a.appendChild(titleP);
            if (windowObj.displayMode === 'full') {
                const urlP = document.createElement('p');
                const urlStrong = document.createElement('strong');
                urlStrong.textContent = 'URL: ';
                urlP.appendChild(urlStrong);
                const urlSpan = document.createElement('span');
                urlSpan.textContent = 'link';
                urlP.appendChild(urlSpan);
                a.appendChild(urlP);
                const tagsP = document.createElement('p');
                const tagsStrong = document.createElement('strong');
                tagsStrong.textContent = 'タグ: ';
                tagsP.appendChild(tagsStrong);
                tagsP.appendChild(document.createTextNode(item.tags ? item.tags.join(', ') : 'なし'));
                a.appendChild(tagsP);
                const dateP = document.createElement('p');
                const dateStrong = document.createElement('strong');
                dateStrong.textContent = '抽出日付: ';
                dateP.appendChild(dateStrong);
                dateP.appendChild(document.createTextNode(item.extractedDate || 'なし'));
                a.appendChild(dateP);
                const saveDateP = document.createElement('p');
                const saveDateStrong = document.createElement('strong');
                saveDateStrong.textContent = '保存日時: ';
                saveDateP.appendChild(saveDateStrong);
                saveDateP.appendChild(document.createTextNode(new Date(item.timestamp).toLocaleString()));
                a.appendChild(saveDateP);
            }
            fragment.appendChild(a);
        });
        itemsDiv.appendChild(fragment);
        if (windowObj.isEditing) addItemClickListeners(windowObj, itemsDiv.querySelectorAll('.savedItem'));
        else itemsDiv.querySelectorAll('.savedItem').forEach(item => item.style.cursor = 'pointer');
    };

    const addItemClickListeners = (windowObj, items) => {
        items.forEach(item => {
            events.removeAll(item);
            item.style.cursor = 'pointer';
            events.add(item, 'click', (e) => {
                if (windowObj.isEditing) {
                    e.preventDefault();
                    const checkbox = item.querySelector('.selectItem');
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        item.classList.toggle('selected', checkbox.checked);
                        item.animate([
                            { transform: 'scale(1)', backgroundColor: '#104437' },
                            { transform: 'scale(1.05)', backgroundColor: '#16a085' },
                            { transform: 'scale(1)', backgroundColor: '#104437' }
                        ], {
                            duration: 200,
                            easing: 'ease-in-out'
                        });
                        logMessage(`アイテムクリック: timestamp=${item.dataset.timestamp}, 選択状態=${checkbox.checked}`);
                    }
                }
            });
        });
    };

    const createLogWindow = () => {
        let existingWindow = document.querySelector('#logWindow');
        if (existingWindow) existingWindow.remove();
        const logWindow = document.createElement('div');
        logWindow.id = 'logWindow';
        const fragment = document.createDocumentFragment();
        const menuBar = document.createElement('div');
        menuBar.className = 'menuBar';
        const title = document.createElement('h3');
        title.textContent = 'log';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'closeLog';
        closeBtn.textContent = '×';
        menuBar.append(title, closeBtn);
        const logContent = document.createElement('div');
        logContent.id = 'logContent';
        fragment.append(menuBar, logContent);
        logWindow.appendChild(fragment);
        document.body.appendChild(logWindow);

        const toolbar = document.getElementById('toolbar');
        if (toolbar) {
            logWindow.style.left = `${toolbar.offsetLeft / window.innerWidth * 100}vw`;
            logWindow.style.top = `${(toolbar.offsetTop + toolbar.offsetHeight + 10) / window.innerHeight * 100}vh`;
        }
        const debugOutput = document.getElementById('debugOutput');
        if (debugOutput) {
            debugOutput.querySelectorAll('p').forEach(p => {
                const logP = document.createElement('p');
                logP.textContent = p.textContent;
                logContent.appendChild(logP);
            });
            logContent.scrollTop = logContent.scrollHeight;
        }
        let isDragging = false, offsetX, offsetY;
        const handleMouseMove = (e) => {
            if (isDragging) {
                let leftPx = e.clientX - offsetX;
                let topPx = e.clientY - offsetY;
                let widthPx = logWindow.offsetWidth;
                let heightPx = logWindow.offsetHeight;
                leftPx = Math.max(0, Math.min(leftPx, window.innerWidth - widthPx));
                topPx = Math.max(0, Math.min(topPx, window.innerHeight - heightPx));
                requestAnimationFrame(() => {
                    logWindow.style.left = `${leftPx}px`;
                    logWindow.style.top = `${topPx}px`;
                });
            }
        };
        const handleMouseUp = () => {
            if (isDragging) {
                isDragging = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        };
        events.add(menuBar, 'mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                isDragging = true;
                offsetX = e.clientX - logWindow.offsetLeft;
                offsetY = e.clientY - logWindow.offsetTop;
                e.preventDefault();
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }
        });
        events.add(closeBtn, 'click', () => logWindow.remove());
        bringToFrontPopup(logWindow);
    };

    const createMoveTabWindow = async (parentWindow, checkboxes) => {
        if (state.activePopup) {
            state.activePopup.remove();
            state.activePopup = null;
        }
        const moveTabDiv = document.createElement('div');
        moveTabDiv.className = 'moveTabPopup';
        const fragment = document.createDocumentFragment();
        const menuBar = document.createElement('div');
        menuBar.className = 'menuBar';
        const title = document.createElement('h3');
        title.textContent = `タブ移動 - ${parentWindow.name}`;
        const closeBtn = document.createElement('button');
        closeBtn.className = 'closeMoveTab';
        closeBtn.textContent = '×';
        menuBar.append(title, closeBtn);
        const content = document.createElement('div');
        content.className = 'moveTabContent';
        content.style.padding = '10px';
        fragment.append(menuBar, content);
        moveTabDiv.appendChild(fragment);
        document.body.appendChild(moveTabDiv);
        state.activePopup = moveTabDiv;
        bringToFrontPopup(moveTabDiv);

        const allItems = await getValue('savedItems', []);
        const autoTabs = new Set(allItems.map(item => item.tab).filter(t => !state.customTabs.has(t)));
        const allTabs = [...state.customTabs, ...autoTabs];
        const contentFragment = document.createDocumentFragment();
        allTabs.forEach(tab => {
            const btn = document.createElement('button');
            btn.textContent = tab;
            events.add(btn, 'click', async () => {
                let allItems = await getValue('savedItems', []);
                checkboxes.forEach(cb => {
                    const timestamp = cb.parentElement.dataset.timestamp;
                    const item = allItems.find(i => i.timestamp === timestamp);
                    if (item) item.tab = tab;
                });
                await setValue('savedItems', allItems);
                displaySavedItems(parentWindow);
                moveTabDiv.remove();
                state.activePopup = null;
            });
            contentFragment.appendChild(btn);
        });
        content.appendChild(contentFragment);
        events.add(closeBtn, 'click', () => {
            moveTabDiv.remove();
            state.activePopup = null;
        });
        return moveTabDiv;
    };

    const createTabManageWindow = async (parentWindow) => {
        if (state.activePopup) {
            state.activePopup.remove();
            state.activePopup = null;
        }
        const tabManageDiv = document.createElement('div');
        tabManageDiv.className = 'tabMenuPopup';
        const fragment = document.createDocumentFragment();
        const menuBar = document.createElement('div');
        menuBar.className = 'menuBar';
        const title = document.createElement('h3');
        title.textContent = `タブ管理 - ${parentWindow.name}`;
        const closeBtn = document.createElement('button');
        closeBtn.className = 'closeTabManage';
        closeBtn.textContent = '×';
        menuBar.append(title, closeBtn);
        const content = document.createElement('div');
        content.className = 'tabManageContent';
        content.style.padding = '10px';
        const label = document.createElement('label');
        label.textContent = 'タブ名: ';
        const input = document.createElement('input');
        input.type = 'text';
        input.id = 'tabNameInput';
        input.placeholder = '新規タブ';
        label.appendChild(input);
        const addBtn = document.createElement('button');
        addBtn.id = 'addTabConfirm';
        addBtn.textContent = '追加';
        const hr = document.createElement('hr');
        const settingsTitle = document.createElement('h4');
        settingsTitle.textContent = 'タブ設定';
        const settingsDiv = document.createElement('div');
        settingsDiv.id = 'tabSettings';
        content.append(label, addBtn, hr, settingsTitle, settingsDiv);
        fragment.append(menuBar, content);
        tabManageDiv.appendChild(fragment);
        document.body.appendChild(tabManageDiv);
        state.activePopup = tabManageDiv;
        bringToFrontPopup(tabManageDiv);

        const allItems = await getValue('savedItems', []);
        const autoTabs = new Set(allItems.map(item => item.tab).filter(t => !state.customTabs.has(t)));
        const allTabs = [...state.customTabs, ...autoTabs];
        const settingsFragment = document.createDocumentFragment();
        allTabs.forEach(tab => {
            const div = document.createElement('div');
            const favicon = allItems.find(item => item.tab === tab)?.favicon;
            div.innerHTML = favicon && !state.customTabs.has(tab) && !state.tabThumbnails.has(tab) ? `<img src="${favicon}" width="16" height="16">` : `<span>${state.tabThumbnails.get(tab) || tab[0]}</span>`;
            div.style.display = 'inline-block';
            div.style.marginRight = '5px';
            div.style.backgroundColor = state.tabColors.get(tab) || '#104437';
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '削除';
            events.add(deleteBtn, 'click', async () => {
                if (confirm(`${tab}タブを削除しますか？（関連アイテムも削除されます）`)) {
                    if (state.customTabs.has(tab)) {
                        state.customTabs.delete(tab);
                        await state.updateCustomTabs([...state.customTabs]);
                    }
                    const updatedItems = allItems.filter(item => item.tab !== tab);
                    await setValue('savedItems', updatedItems);
                    state.tabColors.delete(tab);
                    state.tabThumbnails.delete(tab);
                    if (parentWindow.activeTab === tab) parentWindow.activeTab = state.customTabs.values().next().value || '';
                    updateTabs(parentWindow);
                    content.removeChild(div);
                }
            });
            const colorBtn = document.createElement('button');
            colorBtn.textContent = '色';
            events.add(colorBtn, 'click', () => setupTabColorMenu(tab, div, settingsDiv));
            const thumbnailBtn = document.createElement('button');
            thumbnailBtn.textContent = 'サムネイル';
            functions.add(thumbnailBtn, 'click', () => setupTabThumbnailMenu(tab, div, favicon, settingsDiv));
            div.append(deleteBtn, colorBtn, thumbnailBtn);
            settingsFragment.appendChild(div);
        });
        settingsDiv.appendChild(settingsFragment);
        const handleAddTab = async () => {
            const tabName = input.value;
            if (tabName && !state.customTabs.has(tabName)) {
                state.customTabs.add(tabName);
                await state.updateCustomTabs([...state.customTabs]);
                updateTabs(parentWindow);
                cleanupTabManage(tabManageDiv);
            }
        };
        events.add(addBtn, 'click', handleAddTab);
        events.add(closeBtn, 'click', () => cleanupTabManage(tabManageDiv));
        return tabManageDiv;
    };

    const setupTabColorMenu = (tab, div, settingsDiv) => {
        const colorMenu = document.createElement('div');
        colorMenu.className = 'tabMenu';
        colorMenu.style.position = 'absolute';
        colorMenu.style.left = `${div.offsetLeft + div.offsetWidth}px`;
        colorMenu.style.top = `${div.offsetTop}px`;
        const fragment = document.createDocumentFragment();
        Window.colorPresets.forEach((color, name) => {
            const btn = document.createElement('button');
            btn.textContent = name;
            btn.style.backgroundColor = color;
            events.add(btn, 'click', async () => {
                await state.setTabColor(tab, color);
                div.style.backgroundColor = color;
                updateTabs(state.window);
                colorMenu.remove();
            });
            fragment.appendChild(btn);
        });
        const resetColorBtn = document.createElement('button');
        resetColorBtn.textContent = 'デフォルト色に戻す';
        events.add(resetColorBtn, 'click', async () => {
            state.tabColors.delete(tab);
            await setValue('tabColors', Object.fromEntries(state.tabColors));
            div.style.backgroundColor = '#104437';
            updateTabs(state.window);
            colorMenu.remove();
        });
        fragment.appendChild(resetColorBtn);
        colorMenu.appendChild(fragment);
        settingsDiv.appendChild(colorMenu);
    };

    const setupTabThumbnailMenu = (tab, div, favicon, settingsDiv) => {
        const thumbMenu = document.createElement('div');
        thumbMenu.className = 'tabMenu';
        thumbMenu.style.position = 'absolute';
        thumbMenu.style.left = `${div.offsetLeft + div.offsetWidth}px`;
        thumbMenu.style.top = `${div.offsetTop}px`;
        const fragment = document.createDocumentFragment();
        Window.thumbnailPresets.forEach(emoji => {
            const btn = document.createElement('button');
            btn.textContent = emoji;
            events.add(btn, 'click', async () => {
                await state.setTabThumbnail(tab, emoji);
                div.innerHTML = `<span>${emoji}</span>`;
                updateTabs(state.window);
                thumbMenu.remove();
            });
            fragment.appendChild(btn);
        });
        const resetBtn = document.createElement('button');
        resetBtn.textContent = '元のファビコン';
        events.add(resetBtn, 'click', async () => {
            state.tabThumbnails.delete(tab);
            await setValue('tabThumbnails', Object.fromEntries(state.tabThumbnails));
            div.innerHTML = favicon && !state.customTabs.has(tab) ? `<img src="${favicon}" width="16" height="16">` : `<span>${tab[0]}</span>`;
            updateTabs(state.window);
            thumbMenu.remove();
        });
        fragment.appendChild(resetBtn);
        thumbMenu.appendChild(fragment);
        settingsDiv.appendChild(thumbMenu);
    };

    const cleanupTabManage = (tabManageDiv) => {
        tabManageDiv.querySelectorAll('button').forEach(btn => btn.replaceWith(btn.cloneNode(true)));
        tabManageDiv.remove();
        state.activePopup = null;
    };

    const bringToFront = (windowObj) => {
        state.zIndexCounter++;
        if (state.activePopup && state.zIndexCounter >= parseInt(state.activePopup.style.zIndex)) state.zIndexCounter = parseInt(state.activePopup.style.zIndex) + 1;
        windowObj.el.style.zIndex = state.zIndexCounter;
    };

    const bringToFrontPopup = (popup) => {
        state.zIndexCounter = Math.max(state.zIndexCounter + 1, 20000);
        popup.style.zIndex = state.zIndexCounter;
    };

    const addCloseOnClickOutside = (menu, menuBar) => {
        const closeMenu = (e) => {
            logMessage(`外部クリック検知: target=${e.target.tagName}, menuBar=${menuBar.contains(e.target)}, menu=${menu.contains(e.target)}`);
            setTimeout(() => {
                if (!menuBar.contains(e.target) && !menu.contains(e.target)) {
                    logMessage('サブメニューを閉じます');
                    closeActiveMenu();
                    state.isHoverEnabled = false;
                    document.removeEventListener('click', closeMenu);
                }
            }, 0);
        };
        document.addEventListener('click', closeMenu);
        menu.addEventListener('remove', () => {
            document.removeEventListener('click', closeMenu);
            logMessage('サブメニュー削除に伴いリスナー解除');
        }, { once: true });
    };

    const closeActiveMenu = () => {
        if (state.activeMenu) {
            state.activeMenu.remove();
            state.activeMenu = null;
        }
    };

    const init = async () => {
        const toolbarElements = Toolbar.init();
        if (!toolbarElements) {
            logMessage("ツールバー初期化失敗、中止");
            return;
        }
        let toolbarLeft = Math.max(0, Math.min(window.innerWidth - 80, parseFloat((await getValue('toolbarPosition', { left: window.innerWidth - 80 })).left) || 0));
        let toolbarTop = Math.max(0, Math.min(window.innerHeight - 100, parseFloat((await getValue('toolbarPosition', { top: 50 })).top) || 50));
        toolbarElements.toolbar.style.left = `${toolbarLeft}px`;
        toolbarElements.toolbar.style.top = `${toolbarTop}px`;
        toolbarElements.toolbar.style.right = 'auto';
        logMessage("ツールバー位置設定完了");

        events.add(document, 'fullscreenchange', () => {
            if (document.fullscreenElement) {
                toolbarElements.toolbar.style.display = 'none';
                logMessage("フルスクリーン検知: ツールバーを非表示");
            } else {
                toolbarElements.toolbar.style.display = 'block';
                logMessage("フルスクリーン解除: ツールバーを表示");
            }
        });

        const savedWindowId = await getValue('savedWindow', null);
        if (savedWindowId) {
            const savedState = await getValue(`windowState-${savedWindowId}`, { position: { left: '21px', top: '23px' }, size: { width: '950px', height: '550px' } });
            const windowObj = Window.create(savedWindowId, savedState);
            if (windowObj) await state.setWindow(windowObj);
        }

        window.onresize = () => {
            requestAnimationFrame(async () => {
                const toolbarPos = await getValue('toolbarPosition', { left: `${toolbarLeft}px`, top: `${toolbarTop}px` });
                toolbarElements.toolbar.style.left = `${Math.max(0, Math.min(parseFloat(toolbarPos.left), window.innerWidth - 80))}px`;
                toolbarElements.toolbar.style.top = `${Math.max(0, Math.min(parseFloat(toolbarPos.top), window.innerHeight - 100))}px`;
                if (state.window && state.window.isMaximized) state.window.el.querySelector('.maximizeButton').click();
            });
        };
        logMessage("初期化完了");
    };

    await init();
})();